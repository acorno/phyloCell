<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of phy_inputsdlg</title>
  <meta name="keywords" content="phy_inputsdlg">
  <meta name="description" content="INPUTSDLG Enhanced input dialog box supporting multiple data types">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- # phyloCell -->
<h1>phy_inputsdlg
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>INPUTSDLG Enhanced input dialog box supporting multiple data types</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [Answer,Canceled] = phy_inputsdlg(Prompt, Title, Formats, DefAns, Options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">INPUTSDLG Enhanced input dialog box supporting multiple data types
 ANSWER = INPUTSDLG(PROMPT) creates a modal dialog box that returns user
 input for multiple prompts in the cell array ANSWER. PROMPT is a 1-D
 cell array containing the PROMPT strings.

 Alternatively, PROMPT can be a two-column cell array where the prompt
 string is supplied in the first column. Output ANSWER of the function is
 then in a structure with the field names defined in the second column of
 the PROMPT cell array.

 Moreover, PROMPT may have three columns, where the third column gives
 units (i.e., post-fix labels to the right of controls) to display.

 INPUTSDLG uses UIWAIT to suspend execution until the user responds.

 ANSWER = INPUTSDLG(PROMPT,NAME) specifies the title for the dialog.

 Note that INPUTSDLG(PROMPT) &amp; INPUTSDLG(PROMPT,NAME) are similar to the
 standard INPUTDLG function, except for the dialog layout.

 ANSWER = INPUTSDLG(PROMPT,NAME,FORMATS) can be used to specify the type
 of parameters to display with FORMATS matrix of structures. The
 dimension of FORMATS defines how PROMPT items are laid out in the dialog
 box. For example, if PROMPT has 6 elements and the size of FORMATS is
 2x3 then, the items are shown in 2 rows, 3 columns format.

 The fields in FORMATS structure are:

   type   - Type of control ['check',{'edit'},'list','range','text','none']
   style  - UI control type used. One of:
            [{'checkbox'},       for 'check' type
             {'edit'}            for 'edit' type
              'listbox',{'popupmenu'},'radiobutton','togglebutton'
                                 for 'list' type
             {'slider'}          for 'range' type
             {'text'}]           for 'text' type
   items  - Selection items for 'list' type (cell of strings)
   format - Data format: ['string','float','integer','file','dir']
   limits - [min max] (see below for details)
   size   - [width height] in pixels. Alternatively, 0 to auto-size or -1
            to auto-expand when figure is resized.

 FORMATS type field defines what type of prompt item to be shown.

   type  Description
   -------------------------------------------------------------------
   edit  Standard edit box (single or multi-line mode)
   check Check box for boolean item
   list  Chose from a list of items ('listbox' style allows multiple item
         selection)
   range Use slider to chose a value over a range
   text  Static text (e.g., for instructions)
   none  A placeholder. May be used for its neighboring item to extend
         over multiple columns or rows (i.e., &quot;to merge cells&quot;)

 The allowed data format depends on the type of the field:

   type    allowed format
   --------------------------------------------
   check   integer
   edit    {text}, float, integer, file, dir
   list    integer
   range   float

 By leaving format field empty, a proper format is automatically chosen
 (or default to text format for edit type).

 Formats 'file' and 'dir' for 'edit' type uses the standard UIGETFILE,
 UIPUTFILE, and UIGETDIR functions to retrieve a file or directory name.

 The role of limits field varies depending on other parameters:

   style         role of limits
   ---------------------------------------------------
   checkbox      limits(1) is the ANSWER value if the check box is not
                 selected  box is not selected and limits(2) is the ANSWER
                 if the check box is selected.
   edit (text format)
                 If diff(limits)&gt;1, multi-line mode; else, single-line
                 mode
   edit (numeric format)
                 This style defines the range of allowed values
   edit (file format)
                 If 0&lt;=diff(limits)&lt;=1 uses UIGETFILE in single select
                 mode with single-line edit. If diff(limits)&gt;1 uses
                 UIGETFILE in multi-select mode with multi-line edit. If
                 diff(limits)&lt;0 usees UIPUTFILE with single- line edit
   listbox       If diff(limits)&gt;1, multiple items can be selected
   slider        limits(1) defines the smallest value while
                 limits(2) defines the largest value
   none          If diff(limits)==0 space is left empty
                 If diff(limits)&gt;0 : lets the item from left to extend
                 If diff(limits)&lt;0 : lets the item from above to extend

 Similar to how PROMPT strings are laid out, when FORMATS.style is set to
 either 'radiobutton' or 'togglebutton', FORMATS.items are laid out
 according to the dimension of FORMATS.items.

 There are two quick format options as well:

  Quick Format Option 1 (mimicing INPUTDLG behavior):
   FORMATS can specify the number of lines for each edit-type prompt in
   FORMATS. FORMATS may be a constant value or a column vector having
   one element per PROMPT that specifies how many lines per input field.
   FORMATS may also be a matrix where the first column specifies how
   many rows for the input field and the second column specifies how
   many columns wide the input field should be.

  Quick Format Option 2:
   FORMATS can specify the types of controls and use their default
   configurations. This option, however, cannot be used to specify
   'list' control as its items are not specified. To use this option,
   provide a string (if only 1 control) or a cell array of strings. If
   a cell array is given, its dimension is honored for the dialog
   layout.

 ANSWER = INPUTSDLG(PROMPT,NAME,FORMATS,DEFAULTANSWER) specifies the
 default answer to display for each PROMPT. DEFAULTANSWER must contain
 the same number of elements as PROMPT (that are not of 'none' style). If
 PROMPT does not provide ANSWER structure fields, DEFAULTANSWER should be
 a cell array with element type corresponding to FORMATS.format. Leave the
 cell element empty for a prompt with 'text' type. If ANSWER is a
 structure, DEFAULTANSWER must be a structure with the specified fields.
 (If additional fields are present in DEFAULTANSWER, they will be returned
 as parts of ANSWER.)

 ANSWER = INPUTSDLG(PROMPT,NAME,FORMATS,DEFAULTANSWER,OPTIONS) specifies
 additional options. If OPTIONS is the string 'on', the dialog is made
 resizable. If OPTIONS is a structure, the fields recognized are:

  Option Field Description {} indicates the default value
  ----------------------------------------------------------------------
  Resize        Make dialog resizable: 'on' | {'off'}
  WindowStyle   Sets dialog window style: {'normal'} | 'modal'
  Interpreter   Label text interpreter: 'latex' | {'tex'} | 'none'
  ApplyButton   Adds Apply button: 'on' | {'off'}
  Sep           Space b/w prompts in pixels: {10}

 [ANSWER,CANCELED] = INPUTSDLG(...) returns CANCELED = TRUE if user
 pressed Cancel button, closed the dialog, or pressed ESC. In such event,
 the content of ANSWER is set to the default values.

 Note on Apply Button feature. Pressing the Apply button makes the current
 change permanent. That is, pressing Cancel button after pressing Apply
 button only reverts ANSWER back to the states when the Apply button was
 pressed last. Also, if user pressed Apply button, CANCELED flag will not
 be set even if user canceled out of the dialog box.

 Examples:

 prompt={'Enter the matrix size for x^2:';'Enter the colormap name:'};
 name='Input for Peaks function';
 formats(1) = struct('type','edit','format','integer','limits',[1 inf]);
 formats(2) = struct('type','edit','format','text','limits',[0 1]);
 defaultanswer={20,'hsv'};

 [answer,canceled] = inputsdlg(prompt,name,formats,defaultanswer);

 formats(2).size = -1; % auto-expand width and auto-set height
 options.Resize='on';
 options.WindowStyle='normal';
 options.Interpreter='tex';

 answer = inputsdlg(prompt,name,formats,defaultanswer,options);

 prompt(:,2) = {'Ndim';'Cmap'};
 defaultanswer = struct(defaultanswer,prompt(:,2),1);

 answer = inputsdlg(prompt,name,formats,defaultanswer,options);

 See also INPUTDLG, DIALOG, ERRORDLG, HELPDLG, LISTDLG, MSGBOX,
  QUESTDLG, TEXTWRAP, UIWAIT, WARNDLG, UIGETFILE, UIPUTFILE, UIGETDIR.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="phyloCell_mainGUI.html" class="code" title="function varargout = phyloCell_mainGUI(varargin)">phyloCell_mainGUI</a>	Main graphical user interface;</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function answer = getAnswer(answer,ansstr)</a></li><li><a href="#_sub2" class="code">function doApply(hObj,evd)</a></li><li><a href="#_sub3" class="code">function checkRange(hObj,evd,k,lim)</a></li><li><a href="#_sub4" class="code">function doFigureKeyPress(obj, evd)</a></li><li><a href="#_sub5" class="code">function doControlKeyPress(obj, evd, varargin)</a></li><li><a href="#_sub6" class="code">function doCallback(obj, evd, isok)</a></li><li><a href="#_sub7" class="code">function openFilePrompt(hObj,evd,spec,prompt,mode)</a></li><li><a href="#_sub8" class="code">function openDirPrompt(hObj,evd,prompt)</a></li><li><a href="#_sub9" class="code">function doResize(hObj,evd)</a></li><li><a href="#_sub10" class="code">function [handles,Formats,sinfo] = buildgui(Prompt,Unit,Title,Formats,Options)</a></li><li><a href="#_sub11" class="code">function [Prompt,FieldNames,Units,err] = checkprompt(Prompt)</a></li><li><a href="#_sub12" class="code">function [Formats,err] = checkformats(Formats,NumQuest)</a></li><li><a href="#_sub13" class="code">function [DefAns,DefStr,err] = checkdefaults(DefAns,Formats,FieldNames)</a></li><li><a href="#_sub14" class="code">function [Options,err] = checkoptions(Options)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Answer,Canceled] = phy_inputsdlg(Prompt, Title, Formats, DefAns, Options)</a>
0002 <span class="comment">%INPUTSDLG Enhanced input dialog box supporting multiple data types</span>
0003 <span class="comment">% ANSWER = INPUTSDLG(PROMPT) creates a modal dialog box that returns user</span>
0004 <span class="comment">% input for multiple prompts in the cell array ANSWER. PROMPT is a 1-D</span>
0005 <span class="comment">% cell array containing the PROMPT strings.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Alternatively, PROMPT can be a two-column cell array where the prompt</span>
0008 <span class="comment">% string is supplied in the first column. Output ANSWER of the function is</span>
0009 <span class="comment">% then in a structure with the field names defined in the second column of</span>
0010 <span class="comment">% the PROMPT cell array.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Moreover, PROMPT may have three columns, where the third column gives</span>
0013 <span class="comment">% units (i.e., post-fix labels to the right of controls) to display.</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% INPUTSDLG uses UIWAIT to suspend execution until the user responds.</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% ANSWER = INPUTSDLG(PROMPT,NAME) specifies the title for the dialog.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% Note that INPUTSDLG(PROMPT) &amp; INPUTSDLG(PROMPT,NAME) are similar to the</span>
0020 <span class="comment">% standard INPUTDLG function, except for the dialog layout.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% ANSWER = INPUTSDLG(PROMPT,NAME,FORMATS) can be used to specify the type</span>
0023 <span class="comment">% of parameters to display with FORMATS matrix of structures. The</span>
0024 <span class="comment">% dimension of FORMATS defines how PROMPT items are laid out in the dialog</span>
0025 <span class="comment">% box. For example, if PROMPT has 6 elements and the size of FORMATS is</span>
0026 <span class="comment">% 2x3 then, the items are shown in 2 rows, 3 columns format.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% The fields in FORMATS structure are:</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%   type   - Type of control ['check',{'edit'},'list','range','text','none']</span>
0031 <span class="comment">%   style  - UI control type used. One of:</span>
0032 <span class="comment">%            [{'checkbox'},       for 'check' type</span>
0033 <span class="comment">%             {'edit'}            for 'edit' type</span>
0034 <span class="comment">%              'listbox',{'popupmenu'},'radiobutton','togglebutton'</span>
0035 <span class="comment">%                                 for 'list' type</span>
0036 <span class="comment">%             {'slider'}          for 'range' type</span>
0037 <span class="comment">%             {'text'}]           for 'text' type</span>
0038 <span class="comment">%   items  - Selection items for 'list' type (cell of strings)</span>
0039 <span class="comment">%   format - Data format: ['string','float','integer','file','dir']</span>
0040 <span class="comment">%   limits - [min max] (see below for details)</span>
0041 <span class="comment">%   size   - [width height] in pixels. Alternatively, 0 to auto-size or -1</span>
0042 <span class="comment">%            to auto-expand when figure is resized.</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% FORMATS type field defines what type of prompt item to be shown.</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%   type  Description</span>
0047 <span class="comment">%   -------------------------------------------------------------------</span>
0048 <span class="comment">%   edit  Standard edit box (single or multi-line mode)</span>
0049 <span class="comment">%   check Check box for boolean item</span>
0050 <span class="comment">%   list  Chose from a list of items ('listbox' style allows multiple item</span>
0051 <span class="comment">%         selection)</span>
0052 <span class="comment">%   range Use slider to chose a value over a range</span>
0053 <span class="comment">%   text  Static text (e.g., for instructions)</span>
0054 <span class="comment">%   none  A placeholder. May be used for its neighboring item to extend</span>
0055 <span class="comment">%         over multiple columns or rows (i.e., &quot;to merge cells&quot;)</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% The allowed data format depends on the type of the field:</span>
0058 <span class="comment">%</span>
0059 <span class="comment">%   type    allowed format</span>
0060 <span class="comment">%   --------------------------------------------</span>
0061 <span class="comment">%   check   integer</span>
0062 <span class="comment">%   edit    {text}, float, integer, file, dir</span>
0063 <span class="comment">%   list    integer</span>
0064 <span class="comment">%   range   float</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% By leaving format field empty, a proper format is automatically chosen</span>
0067 <span class="comment">% (or default to text format for edit type).</span>
0068 <span class="comment">%</span>
0069 <span class="comment">% Formats 'file' and 'dir' for 'edit' type uses the standard UIGETFILE,</span>
0070 <span class="comment">% UIPUTFILE, and UIGETDIR functions to retrieve a file or directory name.</span>
0071 <span class="comment">%</span>
0072 <span class="comment">% The role of limits field varies depending on other parameters:</span>
0073 <span class="comment">%</span>
0074 <span class="comment">%   style         role of limits</span>
0075 <span class="comment">%   ---------------------------------------------------</span>
0076 <span class="comment">%   checkbox      limits(1) is the ANSWER value if the check box is not</span>
0077 <span class="comment">%                 selected  box is not selected and limits(2) is the ANSWER</span>
0078 <span class="comment">%                 if the check box is selected.</span>
0079 <span class="comment">%   edit (text format)</span>
0080 <span class="comment">%                 If diff(limits)&gt;1, multi-line mode; else, single-line</span>
0081 <span class="comment">%                 mode</span>
0082 <span class="comment">%   edit (numeric format)</span>
0083 <span class="comment">%                 This style defines the range of allowed values</span>
0084 <span class="comment">%   edit (file format)</span>
0085 <span class="comment">%                 If 0&lt;=diff(limits)&lt;=1 uses UIGETFILE in single select</span>
0086 <span class="comment">%                 mode with single-line edit. If diff(limits)&gt;1 uses</span>
0087 <span class="comment">%                 UIGETFILE in multi-select mode with multi-line edit. If</span>
0088 <span class="comment">%                 diff(limits)&lt;0 usees UIPUTFILE with single- line edit</span>
0089 <span class="comment">%   listbox       If diff(limits)&gt;1, multiple items can be selected</span>
0090 <span class="comment">%   slider        limits(1) defines the smallest value while</span>
0091 <span class="comment">%                 limits(2) defines the largest value</span>
0092 <span class="comment">%   none          If diff(limits)==0 space is left empty</span>
0093 <span class="comment">%                 If diff(limits)&gt;0 : lets the item from left to extend</span>
0094 <span class="comment">%                 If diff(limits)&lt;0 : lets the item from above to extend</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% Similar to how PROMPT strings are laid out, when FORMATS.style is set to</span>
0097 <span class="comment">% either 'radiobutton' or 'togglebutton', FORMATS.items are laid out</span>
0098 <span class="comment">% according to the dimension of FORMATS.items.</span>
0099 <span class="comment">%</span>
0100 <span class="comment">% There are two quick format options as well:</span>
0101 <span class="comment">%</span>
0102 <span class="comment">%  Quick Format Option 1 (mimicing INPUTDLG behavior):</span>
0103 <span class="comment">%   FORMATS can specify the number of lines for each edit-type prompt in</span>
0104 <span class="comment">%   FORMATS. FORMATS may be a constant value or a column vector having</span>
0105 <span class="comment">%   one element per PROMPT that specifies how many lines per input field.</span>
0106 <span class="comment">%   FORMATS may also be a matrix where the first column specifies how</span>
0107 <span class="comment">%   many rows for the input field and the second column specifies how</span>
0108 <span class="comment">%   many columns wide the input field should be.</span>
0109 <span class="comment">%</span>
0110 <span class="comment">%  Quick Format Option 2:</span>
0111 <span class="comment">%   FORMATS can specify the types of controls and use their default</span>
0112 <span class="comment">%   configurations. This option, however, cannot be used to specify</span>
0113 <span class="comment">%   'list' control as its items are not specified. To use this option,</span>
0114 <span class="comment">%   provide a string (if only 1 control) or a cell array of strings. If</span>
0115 <span class="comment">%   a cell array is given, its dimension is honored for the dialog</span>
0116 <span class="comment">%   layout.</span>
0117 <span class="comment">%</span>
0118 <span class="comment">% ANSWER = INPUTSDLG(PROMPT,NAME,FORMATS,DEFAULTANSWER) specifies the</span>
0119 <span class="comment">% default answer to display for each PROMPT. DEFAULTANSWER must contain</span>
0120 <span class="comment">% the same number of elements as PROMPT (that are not of 'none' style). If</span>
0121 <span class="comment">% PROMPT does not provide ANSWER structure fields, DEFAULTANSWER should be</span>
0122 <span class="comment">% a cell array with element type corresponding to FORMATS.format. Leave the</span>
0123 <span class="comment">% cell element empty for a prompt with 'text' type. If ANSWER is a</span>
0124 <span class="comment">% structure, DEFAULTANSWER must be a structure with the specified fields.</span>
0125 <span class="comment">% (If additional fields are present in DEFAULTANSWER, they will be returned</span>
0126 <span class="comment">% as parts of ANSWER.)</span>
0127 <span class="comment">%</span>
0128 <span class="comment">% ANSWER = INPUTSDLG(PROMPT,NAME,FORMATS,DEFAULTANSWER,OPTIONS) specifies</span>
0129 <span class="comment">% additional options. If OPTIONS is the string 'on', the dialog is made</span>
0130 <span class="comment">% resizable. If OPTIONS is a structure, the fields recognized are:</span>
0131 <span class="comment">%</span>
0132 <span class="comment">%  Option Field Description {} indicates the default value</span>
0133 <span class="comment">%  ----------------------------------------------------------------------</span>
0134 <span class="comment">%  Resize        Make dialog resizable: 'on' | {'off'}</span>
0135 <span class="comment">%  WindowStyle   Sets dialog window style: {'normal'} | 'modal'</span>
0136 <span class="comment">%  Interpreter   Label text interpreter: 'latex' | {'tex'} | 'none'</span>
0137 <span class="comment">%  ApplyButton   Adds Apply button: 'on' | {'off'}</span>
0138 <span class="comment">%  Sep           Space b/w prompts in pixels: {10}</span>
0139 <span class="comment">%</span>
0140 <span class="comment">% [ANSWER,CANCELED] = INPUTSDLG(...) returns CANCELED = TRUE if user</span>
0141 <span class="comment">% pressed Cancel button, closed the dialog, or pressed ESC. In such event,</span>
0142 <span class="comment">% the content of ANSWER is set to the default values.</span>
0143 <span class="comment">%</span>
0144 <span class="comment">% Note on Apply Button feature. Pressing the Apply button makes the current</span>
0145 <span class="comment">% change permanent. That is, pressing Cancel button after pressing Apply</span>
0146 <span class="comment">% button only reverts ANSWER back to the states when the Apply button was</span>
0147 <span class="comment">% pressed last. Also, if user pressed Apply button, CANCELED flag will not</span>
0148 <span class="comment">% be set even if user canceled out of the dialog box.</span>
0149 <span class="comment">%</span>
0150 <span class="comment">% Examples:</span>
0151 <span class="comment">%</span>
0152 <span class="comment">% prompt={'Enter the matrix size for x^2:';'Enter the colormap name:'};</span>
0153 <span class="comment">% name='Input for Peaks function';</span>
0154 <span class="comment">% formats(1) = struct('type','edit','format','integer','limits',[1 inf]);</span>
0155 <span class="comment">% formats(2) = struct('type','edit','format','text','limits',[0 1]);</span>
0156 <span class="comment">% defaultanswer={20,'hsv'};</span>
0157 <span class="comment">%</span>
0158 <span class="comment">% [answer,canceled] = inputsdlg(prompt,name,formats,defaultanswer);</span>
0159 <span class="comment">%</span>
0160 <span class="comment">% formats(2).size = -1; % auto-expand width and auto-set height</span>
0161 <span class="comment">% options.Resize='on';</span>
0162 <span class="comment">% options.WindowStyle='normal';</span>
0163 <span class="comment">% options.Interpreter='tex';</span>
0164 <span class="comment">%</span>
0165 <span class="comment">% answer = inputsdlg(prompt,name,formats,defaultanswer,options);</span>
0166 <span class="comment">%</span>
0167 <span class="comment">% prompt(:,2) = {'Ndim';'Cmap'};</span>
0168 <span class="comment">% defaultanswer = struct(defaultanswer,prompt(:,2),1);</span>
0169 <span class="comment">%</span>
0170 <span class="comment">% answer = inputsdlg(prompt,name,formats,defaultanswer,options);</span>
0171 <span class="comment">%</span>
0172 <span class="comment">% See also INPUTDLG, DIALOG, ERRORDLG, HELPDLG, LISTDLG, MSGBOX,</span>
0173 <span class="comment">%  QUESTDLG, TEXTWRAP, UIWAIT, WARNDLG, UIGETFILE, UIPUTFILE, UIGETDIR.</span>
0174 
0175 <span class="comment">% Version 1.11 (Nov. 19, 2009)</span>
0176 <span class="comment">% Written by: Takeshi Ikuma</span>
0177 <span class="comment">% Contributer: Andreas Greuer</span>
0178 <span class="comment">% Created: Nov. 16, 2009</span>
0179 <span class="comment">% Revision History:</span>
0180 <span class="comment">%  v.1.1 (Nov. 19, 2009)</span>
0181 <span class="comment">%  * Fixed bugs (reported by AG):</span>
0182 <span class="comment">%   - not returning Canceled output</span>
0183 <span class="comment">%   - erroneous struct output behavior</span>
0184 <span class="comment">%   - error if all row elements of a column are auto-expandable</span>
0185 <span class="comment">%  * Added Apply button option</span>
0186 <span class="comment">%  * Added support for Units (label to the right of controls)</span>
0187 <span class="comment">%  * Updated the help text</span>
0188 <span class="comment">%  v.1.11 (Nov. 20, 2009)</span>
0189 <span class="comment">%  * Fixed bugs (reported by AG):</span>
0190 <span class="comment">%   - incorrect Canceled output when Cancel button is pressed</span>
0191 <span class="comment">%  v.1.12 (Nov. 20, 2009)</span>
0192 <span class="comment">%  * Fixed bugs (reported by AG):</span>
0193 <span class="comment">%   - again incorrect Canceled output behavior</span>
0194 
0195 <span class="comment">%%%%%%%%%%%%%%%%%%%%</span>
0196 <span class="comment">%%% Nargin Check %%%</span>
0197 <span class="comment">%%%%%%%%%%%%%%%%%%%%</span>
0198 error(nargchk(0,5,nargin));
0199 error(nargoutchk(0,2,nargout));
0200 
0201 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0202 <span class="comment">%%% Handle Input Args %%%</span>
0203 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0204 <span class="keyword">if</span> nargin&lt;1, Prompt=<span class="string">''</span>; <span class="keyword">end</span>
0205 <span class="keyword">if</span> nargin&lt;2, Title = <span class="string">''</span>; <span class="keyword">end</span>
0206 <span class="keyword">if</span> nargin&lt;3, Formats=struct([]); <span class="keyword">end</span>
0207 <span class="keyword">if</span> nargin&lt;4, DefAns = {}; <span class="keyword">end</span>
0208 <span class="keyword">if</span> nargin&lt;5, Options = struct([]); <span class="keyword">end</span>
0209 
0210 <span class="comment">% Check Prompt input</span>
0211 [Prompt,FieldNames,Units,err] = <a href="#_sub11" class="code" title="subfunction [Prompt,FieldNames,Units,err] = checkprompt(Prompt)">checkprompt</a>(Prompt);
0212 <span class="keyword">if</span> ~isempty(err), error(err{:}); <span class="keyword">end</span>
0213 NumQuest = numel(Prompt); <span class="comment">% number of prompts</span>
0214 
0215 <span class="keyword">if</span> isempty(Title)
0216    Title = <span class="string">' '</span>;
0217 <span class="keyword">elseif</span> iscellstr(Title)
0218    Title = Title{1}; <span class="comment">% take the first entry</span>
0219 <span class="keyword">elseif</span> ~ischar(Title)
0220    error(<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Title must be a string of cell string.'</span>);
0221 <span class="keyword">end</span>
0222 
0223 <span class="comment">% make sure that the Formats structure is valid &amp; fill it in default</span>
0224 <span class="comment">% values as needed</span>
0225 [Formats,err] = <a href="#_sub12" class="code" title="subfunction [Formats,err] = checkformats(Formats,NumQuest)">checkformats</a>(Formats,NumQuest);
0226 <span class="keyword">if</span> ~isempty(err), error(err{:}); <span class="keyword">end</span>
0227 
0228 <span class="comment">% make sure that the DefAns is valid &amp; set Answer using DefAns and default</span>
0229 <span class="comment">% values if DefAns not given</span>
0230 [Answer,AnsStr,err] = <a href="#_sub13" class="code" title="subfunction [DefAns,DefStr,err] = checkdefaults(DefAns,Formats,FieldNames)">checkdefaults</a>(DefAns,Formats,FieldNames);
0231 <span class="keyword">if</span> ~isempty(err), error(err{:}); <span class="keyword">end</span>
0232 
0233 <span class="comment">% make sure that the Options is valid</span>
0234 [Options,err] = <a href="#_sub14" class="code" title="subfunction [Options,err] = checkoptions(Options)">checkoptions</a>(Options);
0235 <span class="keyword">if</span> ~isempty(err), error(err{:}); <span class="keyword">end</span>
0236 
0237 Applied = false; <span class="comment">% set true by pressing Apply Button</span>
0238 
0239 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0240 <span class="comment">%%% Create Dialog GUI %%%</span>
0241 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0242 <span class="comment">% lay contents out on a dialog box</span>
0243 [handles,Formats,sinfo] = <a href="#_sub10" class="code" title="subfunction [handles,Formats,sinfo] = buildgui(Prompt,Unit,Title,Formats,Options)">buildgui</a>(Prompt,Units,Title,Formats,Options);
0244 
0245 <span class="comment">% set default values</span>
0246 <span class="keyword">for</span> k = 1:NumQuest
0247    <span class="keyword">switch</span> Formats(k).style
0248       <span class="keyword">case</span> {<span class="string">'checkbox'</span> <span class="string">'listbox'</span> <span class="string">'popupmenu'</span> <span class="string">'slider'</span>}
0249          set(handles.ctrl(k),<span class="string">'Value'</span>,Answer{k});
0250       <span class="keyword">case</span> <span class="string">'edit'</span>
0251          <span class="keyword">if</span> any(strcmp(Formats(k).format,{<span class="string">'integer'</span>,<span class="string">'float'</span>}))
0252             set(handles.ctrl(k),<span class="string">'String'</span>,num2str(Answer{k}));
0253          <span class="keyword">else</span>
0254             set(handles.ctrl(k),<span class="string">'String'</span>,Answer{k});
0255          <span class="keyword">end</span>
0256       <span class="keyword">case</span> {<span class="string">'radiobutton'</span> <span class="string">'togglebutton'</span>}
0257          h = get(handles.ctrl(k),<span class="string">'UserData'</span>);
0258          set(handles.ctrl(k),<span class="string">'SelectedObject'</span>,h(Answer{k}));
0259    <span class="keyword">end</span>
0260 <span class="keyword">end</span>
0261 
0262 <span class="comment">% set callback functions</span>
0263 <span class="keyword">for</span> k = 1:NumQuest <span class="comment">% for all non-'text' controls</span>
0264    <span class="keyword">if</span> strcmp(Formats(k).style,<span class="string">'edit'</span>)
0265       <span class="keyword">switch</span> Formats(k).format
0266          <span class="keyword">case</span> {<span class="string">'float'</span>,<span class="string">'integer'</span>}
0267             <span class="comment">% for numeric edit box, check for the range &amp; set mouse down behavior</span>
0268             set(handles.ctrl(k),<span class="string">'Callback'</span>,@(hObj,evd)<a href="#_sub3" class="code" title="subfunction checkRange(hObj,evd,k,lim) ">checkRange</a>(hObj,evd,k,Formats(k).limits));
0269          <span class="keyword">case</span> <span class="string">'file'</span>
0270             mode = diff(Formats(k).limits);
0271             set(handles.ctrl(k),<span class="keyword">...</span>
0272                <span class="string">'ButtonDownFcn'</span>,@(hObj,evd)<a href="#_sub7" class="code" title="subfunction openFilePrompt(hObj,evd,spec,prompt,mode) ">openFilePrompt</a>(hObj,evd,Formats(k).items,Prompt{k},mode),<span class="keyword">...</span>
0273                <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0274          <span class="keyword">case</span> <span class="string">'dir'</span>
0275             set(handles.ctrl(k),<span class="keyword">...</span>
0276                <span class="string">'ButtonDownFcn'</span>,@(hObj,evd)<a href="#_sub8" class="code" title="subfunction openDirPrompt(hObj,evd,prompt) ">openDirPrompt</a>(hObj,evd,Prompt{k}),<span class="keyword">...</span>
0277                <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0278       <span class="keyword">end</span>
0279    <span class="keyword">end</span>
0280 <span class="keyword">end</span>
0281 
0282 set(handles.fig,<span class="string">'UserData'</span>,<span class="string">'Cancel'</span>);
0283 set(handles.btns(1), <span class="string">'KeyPressFcn'</span>, @(hObj,evd)<a href="#_sub5" class="code" title="subfunction doControlKeyPress(obj, evd, varargin)">doControlKeyPress</a>(hObj,evd,true), <span class="string">'Callback'</span> ,@(hObj,evd)<a href="#_sub6" class="code" title="subfunction doCallback(obj, evd, isok) ">doCallback</a>(hObj,evd,true));
0284 set(handles.btns(2), <span class="string">'KeyPressFcn'</span>, @(hObj,evd)<a href="#_sub5" class="code" title="subfunction doControlKeyPress(obj, evd, varargin)">doControlKeyPress</a>(hObj,evd,false), <span class="string">'Callback'</span> ,@(hObj,evd)<a href="#_sub6" class="code" title="subfunction doCallback(obj, evd, isok) ">doCallback</a>(hObj,evd,false));
0285 <span class="keyword">if</span> numel(handles.btns)&gt;2
0286    set(handles.btns(3), <span class="string">'KeyPressFcn'</span>, @(hObj,evd)<a href="#_sub5" class="code" title="subfunction doControlKeyPress(obj, evd, varargin)">doControlKeyPress</a>(hObj,evd), <span class="string">'Callback'</span> ,@<a href="#_sub2" class="code" title="subfunction doApply(hObj,evd) ">doApply</a>);
0287 <span class="keyword">end</span>
0288 set(handles.fig, <span class="string">'KeyPressFcn'</span>, @<a href="#_sub4" class="code" title="subfunction doFigureKeyPress(obj, evd)">doFigureKeyPress</a>,<span class="string">'ResizeFcn'</span>, @<a href="#_sub9" class="code" title="subfunction doResize(hObj,evd) ">doResize</a>);
0289 
0290 <span class="comment">% make sure we are on screen</span>
0291 movegui(handles.fig)
0292 
0293 <span class="comment">% if there is a figure out there and it's modal, we need to be modal too</span>
0294 <span class="keyword">if</span> ~isempty(gcbf) &amp;&amp; strcmp(get(gcbf,<span class="string">'WindowStyle'</span>),<span class="string">'modal'</span>)
0295    set(handles.Figure,<span class="string">'WindowStyle'</span>,<span class="string">'modal'</span>);
0296 <span class="keyword">end</span>
0297 
0298 <span class="comment">% ready to begin the show!</span>
0299 set(handles.fig,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0300 drawnow;
0301 
0302 <span class="comment">% set focus on the first uicontol</span>
0303 h = handles.ctrl(find(~strcmp(<span class="string">'text'</span>,{Formats.type}),1,<span class="string">'first'</span>));
0304 <span class="keyword">if</span> ~isempty(h)
0305    <span class="keyword">switch</span> get(h,<span class="string">'type'</span>)
0306       <span class="keyword">case</span> <span class="string">'uicontrol'</span>, uicontrol(h);
0307       <span class="keyword">case</span> <span class="string">'uitoggletool'</span>, uicontrol(get(h,<span class="string">'SelectedObject'</span>));
0308    <span class="keyword">end</span>
0309 <span class="keyword">end</span>
0310 
0311 <span class="comment">% Go into uiwait if the figure handle is still valid.</span>
0312 <span class="comment">% This is mostly the case during regular use.</span>
0313 <span class="keyword">if</span> ishghandle(handles.fig), uiwait(handles.fig); <span class="keyword">end</span>
0314 
0315 <span class="comment">% Check handle validity again since we may be out of uiwait because the</span>
0316 <span class="comment">% figure was deleted.</span>
0317 Canceled = ~(Applied || (ishghandle(handles.fig) &amp;&amp; strcmp(get(handles.fig,<span class="string">'UserData'</span>),<span class="string">'OK'</span>)));
0318 <span class="keyword">if</span> Canceled <span class="comment">% return the default answer</span>
0319    <span class="keyword">if</span> isempty(FieldNames), Answer = DefAns;
0320    <span class="keyword">else</span> Answer = AnsStr; <span class="keyword">end</span> <span class="comment">% AnsStr contains the default value until getAnswer is called</span>
0321 <span class="keyword">else</span>
0322    Answer = <a href="#_sub1" class="code" title="subfunction answer = getAnswer(answer,ansstr)">getAnswer</a>(Answer,AnsStr); <span class="comment">% get the final answers</span>
0323 <span class="keyword">end</span>
0324 
0325 <span class="comment">% Close the figure if it's still open</span>
0326 <span class="keyword">if</span> ishghandle(handles.fig), delete(handles.fig); <span class="keyword">end</span>
0327 
0328 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0329 <span class="comment">%%% NESTED FUNCTIONS</span>
0330 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0331    <span class="keyword">function</span> answer = <a href="#_sub1" class="code" title="subfunction answer = getAnswer(answer,ansstr)">getAnswer</a>(answer,ansstr)
0332       <span class="comment">% retrieve answer from controls</span>
0333       <span class="keyword">for</span> i = 1:numel(answer)
0334          <span class="keyword">switch</span> Formats(i).style
0335             <span class="keyword">case</span> {<span class="string">'checkbox'</span> <span class="string">'listbox'</span> <span class="string">'popupmenu'</span> <span class="string">'slider'</span>}
0336                answer{i} = get(handles.ctrl(i),<span class="string">'Value'</span>);
0337             <span class="keyword">case</span> <span class="string">'edit'</span>
0338                <span class="keyword">switch</span> Formats(i).format
0339                   <span class="keyword">case</span> {<span class="string">'text'</span> <span class="string">'dir'</span>}
0340                      answer{i} = get(handles.ctrl(i),<span class="string">'String'</span>);
0341                   <span class="keyword">case</span> <span class="string">'file'</span>
0342                      data = get(handles.ctrl(i),<span class="string">'UserData'</span>);
0343                      <span class="keyword">if</span> isempty(data)
0344                         answer{i} = get(handles.ctrl(i),<span class="string">'String'</span>);
0345                      <span class="keyword">else</span> <span class="comment">% multi-select</span>
0346                         answer{i} = strcat(data{1},data{2});
0347                      <span class="keyword">end</span>
0348                   <span class="keyword">otherwise</span>
0349                      answer{i} = str2double(get(handles.ctrl(i),<span class="string">'String'</span>));
0350                <span class="keyword">end</span>
0351             <span class="keyword">case</span> {<span class="string">'radiobutton'</span> <span class="string">'togglebutton'</span>}
0352                answer{i} = find(get(handles.ctrl(i),<span class="string">'SelectedObject'</span>)==get(handles.ctrl(i),<span class="string">'UserData'</span>));
0353          <span class="keyword">end</span>
0354       <span class="keyword">end</span>
0355       
0356       <span class="comment">% if struct answer expected, copy</span>
0357       <span class="keyword">if</span> ~isempty(FieldNames)
0358          idx = find(~cellfun(<span class="string">'isempty'</span>,FieldNames))';
0359          <span class="keyword">for</span> i = idx
0360             ansstr.(FieldNames{i}) = answer{i};
0361          <span class="keyword">end</span>
0362          answer = ansstr;
0363       <span class="keyword">end</span>
0364    <span class="keyword">end</span>
0365 
0366    <span class="keyword">function</span> <a href="#_sub2" class="code" title="subfunction doApply(hObj,evd) ">doApply</a>(hObj,evd) <span class="comment">%#ok</span>
0367       Applied = true; <span class="comment">% set the flag</span>
0368       DefAns = <a href="#_sub1" class="code" title="subfunction answer = getAnswer(answer,ansstr)">getAnswer</a>(Answer,AnsStr);
0369       <span class="keyword">if</span> isstruct(DefAns)
0370          DefStr = DefAns;
0371          DefAns = cell(size(FieldNames));
0372          idx = find(~cellfun(<span class="string">'isempty'</span>,FieldNames))';
0373          <span class="keyword">for</span> i = idx
0374             DefAns{i} = DefStr.(FieldNames{i});
0375          <span class="keyword">end</span>
0376       <span class="keyword">end</span>
0377    <span class="keyword">end</span>
0378 
0379    <span class="keyword">function</span> <a href="#_sub3" class="code" title="subfunction checkRange(hObj,evd,k,lim) ">checkRange</a>(hObj,evd,k,lim) <span class="comment">%#ok</span>
0380       val = str2double(get(hObj,<span class="string">'String'</span>));
0381       <span class="keyword">if</span> ~isnan(val) &amp;&amp; val&gt;=lim(1) &amp;&amp; val&lt;=lim(2)
0382          Answer{k} = val;
0383       <span class="keyword">else</span>
0384          <span class="keyword">if</span> strcmp(Formats(k).format,<span class="string">'integer'</span>)
0385             msg = sprintf(<span class="string">'%d, %d'</span>,lim(1),lim(2));
0386          <span class="keyword">else</span>
0387             msg = sprintf(<span class="string">'%g, %g'</span>,lim(1),lim(2));
0388          <span class="keyword">end</span>
0389          h = errordlg(sprintf(<span class="string">'This parameter must be within the range [%s].'</span>,msg),<span class="string">'Invalid Value'</span>,<span class="string">'modal'</span>);
0390          uiwait(h);
0391          set(hObj,<span class="string">'String'</span>,num2str(Answer{k}));
0392       <span class="keyword">end</span>
0393    <span class="keyword">end</span>
0394 
0395    <span class="keyword">function</span> <a href="#_sub4" class="code" title="subfunction doFigureKeyPress(obj, evd)">doFigureKeyPress</a>(obj, evd)
0396       <span class="keyword">switch</span>(evd.Key)
0397          <span class="keyword">case</span> {<span class="string">'return'</span>,<span class="string">'space'</span>}
0398             set(obj,<span class="string">'UserData'</span>,<span class="string">'OK'</span>);
0399             uiresume(obj);
0400          <span class="keyword">case</span> {<span class="string">'escape'</span>}
0401             delete(obj);
0402       <span class="keyword">end</span>
0403    <span class="keyword">end</span>
0404 
0405    <span class="keyword">function</span> <a href="#_sub5" class="code" title="subfunction doControlKeyPress(obj, evd, varargin)">doControlKeyPress</a>(obj, evd, varargin)
0406       <span class="keyword">switch</span>(evd.Key)
0407          <span class="keyword">case</span> {<span class="string">'return'</span>} <span class="comment">% execute its callback function with varargin</span>
0408             cbfcn = get(obj,<span class="string">'Callback'</span>);
0409             cbfcn(obj,evd);
0410          <span class="keyword">case</span> <span class="string">'escape'</span>
0411             delete(gcbf)
0412       <span class="keyword">end</span>
0413    <span class="keyword">end</span>
0414 
0415    <span class="keyword">function</span> <a href="#_sub6" class="code" title="subfunction doCallback(obj, evd, isok) ">doCallback</a>(obj, evd, isok) <span class="comment">%#ok</span>
0416       <span class="keyword">if</span> isok || Applied
0417          set(gcbf,<span class="string">'UserData'</span>,<span class="string">'OK'</span>);
0418          uiresume(gcbf);
0419       <span class="keyword">else</span>
0420          delete(gcbf)
0421       <span class="keyword">end</span>
0422    <span class="keyword">end</span>
0423 
0424    <span class="keyword">function</span> <a href="#_sub7" class="code" title="subfunction openFilePrompt(hObj,evd,spec,prompt,mode) ">openFilePrompt</a>(hObj,evd,spec,prompt,mode) <span class="comment">%#ok</span>
0425       
0426       <span class="keyword">if</span> mode&lt;0 <span class="comment">% uiputfile</span>
0427          [f,p] = uiputfile(spec,prompt,get(hObj,<span class="string">'String'</span>));
0428          <span class="keyword">if</span> f~=0, set(hObj,<span class="string">'String'</span>,[p f]); <span class="keyword">end</span>
0429       <span class="keyword">elseif</span> mode&lt;=1 <span class="comment">% uigetfile</span>
0430          [f,p] = uigetfile(spec,prompt,get(hObj,<span class="string">'String'</span>));
0431          <span class="keyword">if</span> f~=0, set(hObj,<span class="string">'String'</span>,[p f]); <span class="keyword">end</span>
0432       <span class="keyword">else</span> <span class="comment">% uigetfile multi-select</span>
0433          <span class="comment">% previously chosen files are lost, but directly is kept</span>
0434          data = get(hObj,<span class="string">'UserData'</span>);
0435          [f,p] = uigetfile(spec,prompt,data{1},<span class="string">'MultiSelect'</span>,<span class="string">'on'</span>);
0436          <span class="keyword">if</span> p~=0
0437             data = {p f};
0438             <span class="keyword">if</span> ischar(f) <span class="comment">% single file selected</span>
0439                set(hObj,<span class="string">'String'</span>,[p f],<span class="string">'UserData'</span>,data);
0440             <span class="keyword">else</span> <span class="comment">% multiple files selected</span>
0441                str = sprintf(<span class="string">'&quot;%s%s&quot;'</span>,p,f{1});
0442                <span class="keyword">for</span> n = 2:length(f)
0443                   str = sprintf(<span class="string">'%s\n&quot;%s%s&quot;'</span>,str,p,f{n});
0444                <span class="keyword">end</span>
0445                set(hObj,<span class="string">'String'</span>,str,<span class="string">'UserData'</span>,data);
0446             <span class="keyword">end</span>
0447          <span class="keyword">end</span>
0448       <span class="keyword">end</span>
0449       uicontrol(hObj);
0450    <span class="keyword">end</span>
0451 
0452    <span class="keyword">function</span> <a href="#_sub8" class="code" title="subfunction openDirPrompt(hObj,evd,prompt) ">openDirPrompt</a>(hObj,evd,prompt) <span class="comment">%#ok</span>
0453       p = uigetdir(get(hObj,<span class="string">'String'</span>),prompt);
0454       <span class="keyword">if</span> p~=0, set(hObj,<span class="string">'String'</span>,p); <span class="keyword">end</span>
0455       uicontrol(hObj);
0456    <span class="keyword">end</span>
0457 
0458    <span class="keyword">function</span> <a href="#_sub9" class="code" title="subfunction doResize(hObj,evd) ">doResize</a>(hObj,evd) <span class="comment">%#ok</span>
0459       <span class="comment">% This function places all controls in proper place.</span>
0460       <span class="comment">% Must be called before the GUI is made visible as buildgui function</span>
0461       <span class="comment">% just creates uicontrols and do not place them in proper places.</span>
0462       
0463       <span class="comment">% get current figure size</span>
0464       figPos = get(hObj,<span class="string">'Position'</span>);
0465       figSize = figPos(3:4);
0466       
0467       <span class="comment">% determine the column width &amp; row heights</span>
0468       workarea = [Options.Sep Options.Sep figSize - 2*Options.Sep]; <span class="comment">% Options.Sep margins around the figure</span>
0469       btnarea = [0,0,workarea(3),sinfo.h_btns];
0470       ctrlarea = [0,btnarea(4)+Options.Sep,workarea(3),workarea(4)-sinfo.h_btns];
0471       
0472       dim = size(sinfo.map);
0473       num = numel(handles.ctrl);
0474       
0475       <span class="comment">% determine the column widths &amp; margin</span>
0476       w = sinfo.w_ctrls+sinfo.w_labels+sinfo.w_units; <span class="comment">% minimum widths of elements</span>
0477       width = zeros(size(sinfo.map));
0478       cext = false(1,dim(2));
0479       <span class="keyword">for</span> n = 1:dim(2)
0480          cmap = sinfo.map(:,n);
0481          cext(n) = any(sinfo.autoextend(cmap(cmap~=0),1));
0482       <span class="keyword">end</span>
0483       <span class="keyword">if</span> any(cext) <span class="comment">% found auto-extendable element(s)</span>
0484          m_col = Options.Sep; <span class="comment">% column margin fixed</span>
0485          w_total = ctrlarea(3)-(dim(2)+1)*m_col; <span class="comment">% sum of control width</span>
0486          
0487          <span class="comment">% record the widths of non-expandable elements</span>
0488          <span class="keyword">for</span> n = find(~sinfo.autoextend(:,1))'
0489             idx = find(sinfo.map==n);
0490             [i,j] = ind2sub(dim,idx);
0491             J = unique(j);
0492             n_col = numel(J);
0493             width(idx) = (w(n)-(n_col-1)*m_col)/n_col;
0494          <span class="keyword">end</span>
0495          w_col = max(width,[],1); <span class="comment">% column width based on non-expandables</span>
0496          
0497          <span class="comment">% figure out how to distribute extra spaces among auto-expandable columns</span>
0498          w_avail = w_total - sum(w_col(~cext)); <span class="comment">% available width</span>
0499          idx = w_col(cext)==0; <span class="comment">% column where all elements are auto-expandable</span>
0500          <span class="keyword">if</span> all(idx) <span class="comment">% all columns auto-expandable</span>
0501             w_col(cext) = w_avail/sum(cext); <span class="comment">% equally distributed</span>
0502          <span class="keyword">else</span>
0503             w_xcol = w_col(cext);
0504             <span class="keyword">if</span> any(idx)
0505                w_xcol(idx) = mean(w_xcol(~idx));
0506             <span class="keyword">end</span> <span class="comment">% some columns are auto-expandable</span>
0507             w_xcol = w_xcol + (w_avail-sum(w_xcol))/sum(cext); <span class="comment">% equally distribute the excess</span>
0508             w_col(cext) = w_xcol;
0509          <span class="keyword">end</span>
0510          
0511          w_col = max(w_col,1); <span class="comment">% make sure it's positive</span>
0512          
0513          <span class="comment">% set the expandable controls' width</span>
0514          <span class="keyword">for</span> n = find(sinfo.autoextend(:,1))'
0515             idx = find(sinfo.map==n);
0516             [i,j] = ind2sub(dim,idx);
0517             J = unique(j);
0518             <span class="keyword">if</span> strcmp(Formats(n).type,<span class="string">'text'</span>)
0519                sinfo.w_labels(n) = sum(w_col(J));
0520             <span class="keyword">else</span>
0521                sinfo.w_ctrls(n) = max(sum(w_col(J)) - sinfo.w_labels(n),1);
0522             <span class="keyword">end</span>
0523          <span class="keyword">end</span>
0524       <span class="keyword">else</span> <span class="comment">% no auto-extension, adjust column margin</span>
0525          <span class="keyword">for</span> n = 1:num
0526             idx = find(sinfo.map==n);
0527             [i,j] = ind2sub(dim,idx);
0528             J = unique(j);
0529             n_col = numel(J);
0530             width(idx) = w(n)/n_col;
0531          <span class="keyword">end</span>
0532          w_col = max(width,[],1);
0533          m_col = (ctrlarea(3)-sum(w_col))/(dim(2)+1);
0534       <span class="keyword">end</span>
0535       
0536       <span class="comment">% resize static text with auto-height</span>
0537       aex = sinfo.autoextend;
0538       <span class="keyword">for</span> m = find(strcmp(<span class="string">'text'</span>,{Formats.type}) &amp; any(sinfo.autoextend(:,2)))
0539          idx = find(sinfo.map==m);
0540          [i,j] = ind2sub(dim,idx);
0541          J = unique(j);
0542          w = sum(w_col(J)) + (numel(J)-1)*m_col;
0543          <span class="keyword">if</span> w&lt;=100, w = 100; <span class="keyword">end</span>
0544          
0545          <span class="comment">% create dummy uicontrol to wrap text</span>
0546          h = uicontrol(<span class="string">'Parent'</span>,hObj,<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="string">'Position'</span>,[0 0 w 20],<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0547          msg = textwrap(h,Prompt(m));
0548          delete(h);
0549          str = msg{1};
0550          <span class="keyword">for</span> n = 2:length(msg)
0551             str = sprintf(<span class="string">'%s\n%s'</span>,str,msg{n});
0552          <span class="keyword">end</span>
0553          
0554          <span class="comment">% update the text wrapping</span>
0555          set(handles.labels(m),<span class="string">'String'</span>,str);
0556          
0557          <span class="comment">% get updated size</span>
0558          pos = get(handles.labels(m),<span class="string">'Extent'</span>);
0559          sinfo.w_labels(m) = pos(3);
0560          sinfo.h_labels(m) = pos(4);
0561          sinfo.h_ctrls(m) = pos(4);
0562          
0563          aex(m,2) = false;
0564       <span class="keyword">end</span>
0565       
0566       <span class="comment">% determine the row heights &amp; margin</span>
0567       h = max([sinfo.h_ctrls,sinfo.h_labels,sinfo.h_units],[],2);
0568       height = zeros(size(sinfo.map));
0569       rext = false(dim(1),1);
0570       <span class="keyword">for</span> n = 1:dim(1)
0571          cmap = sinfo.map(n,:);
0572          rext(n) = any(aex(cmap(cmap~=0),2));
0573       <span class="keyword">end</span>
0574       <span class="keyword">if</span> any(rext)
0575          m_row = Options.Sep; <span class="comment">% column margin fixed</span>
0576          h_total = ctrlarea(4)-(dim(1)+1)*m_row; <span class="comment">% sum of control width</span>
0577          
0578          <span class="comment">% record the heightss of non-expandable elements</span>
0579          <span class="keyword">for</span> n = find(~aex(:,2))'
0580             idx = find(sinfo.map==n);
0581             [i,j] = ind2sub(dim,idx); <span class="comment">%#ok</span>
0582             I = unique(i);
0583             n_row = numel(I);
0584             height(idx) = (h(n)-(n_row-1)*m_row)/n_row;
0585          <span class="keyword">end</span>
0586          h_row = max(height,[],2); <span class="comment">% column width based on non-expandables</span>
0587          
0588          <span class="comment">% figure out how to distribute extra spaces among auto-expandable rows</span>
0589          h_avail = h_total - sum(h_row(~rext)); <span class="comment">% available width</span>
0590          idx = h_row(rext)==0; <span class="comment">% column where all elements are auto-expandable</span>
0591          <span class="keyword">if</span> all(idx) <span class="comment">% all columns auto-expandable</span>
0592             h_row(rext) = h_avail/sum(rext); <span class="comment">% equally distributed</span>
0593          <span class="keyword">else</span>
0594             h_xrow = h_row(rext);
0595             <span class="keyword">if</span> any(idx), h_xrow(idx) = mean(h_xrow(~idx)); <span class="keyword">end</span> <span class="comment">% some columns are auto-expandable</span>
0596             h_xrow = h_xrow + (h_avail-sum(h_xrow))/sum(rext); <span class="comment">% equally distribute the excess</span>
0597             h_row(rext) = h_xrow;
0598          <span class="keyword">end</span>
0599          
0600          h_row = max(h_row,1);
0601          
0602          <span class="comment">% set the expandable controls width</span>
0603          <span class="keyword">for</span> n = find(aex(:,2))'
0604             idx = find(sinfo.map==n);
0605             [i,j] = ind2sub(dim,idx); <span class="comment">%#ok</span>
0606             I = unique(i);
0607             n_row = numel(I);
0608             newh = sum(h_row(I)) + (n_row-1)*m_row;
0609             change = newh - sinfo.h_ctrls(n);
0610             sinfo.h_ctrls(n) = newh;
0611             sinfo.CLoffset(n) = sinfo.CLoffset(n) + change;
0612             sinfo.CUoffset(n) = sinfo.CUoffset(n) + change;
0613          <span class="keyword">end</span>
0614       <span class="keyword">else</span> <span class="comment">% no auto-extension in heights, adjust row margin</span>
0615          <span class="keyword">for</span> n = 1:num
0616             idx = find(sinfo.map==n);
0617             [i,j] = ind2sub(dim,idx); <span class="comment">%#ok</span>
0618             I = unique(i);
0619             n_row = numel(I);
0620             height(idx) = h(n)/n_row;
0621          <span class="keyword">end</span>
0622          h_row = max(height,[],2);
0623          m_row = (ctrlarea(4)-sum(h_row))/(dim(1)+1);
0624       <span class="keyword">end</span>
0625       
0626       <span class="comment">% set control positions</span>
0627       <span class="keyword">for</span> m = 1:num
0628          [i,j] = ind2sub(dim,find(sinfo.map==m));
0629          x0 = sum(w_col(1:j(1)-1)) + m_col*j(1) + ctrlarea(1) + workarea(1);
0630          y0 = sum(h_row(i(1):end)) - sinfo.h_ctrls(m) + m_row*(dim(1)-i(1)+1) + ctrlarea(2) + workarea(2);
0631          
0632          posL = [x0,y0+sinfo.CLoffset(m)];
0633          posC = [x0+sinfo.w_labels(m),y0,sinfo.w_ctrls(m),sinfo.h_ctrls(m)];
0634          posU = [x0+sinfo.w_labels(m)+sinfo.w_ctrls(m)+2,y0+sinfo.CUoffset(m)];
0635          
0636          <span class="keyword">if</span> handles.labels(m)~=0, set(handles.labels(m),<span class="string">'Position'</span>,posL); <span class="keyword">end</span>
0637          <span class="keyword">if</span> handles.ctrl(m)~=0, set(handles.ctrl(m),<span class="string">'Position'</span>,posC); <span class="keyword">end</span>
0638          <span class="keyword">if</span> handles.units(m)~=0, set(handles.units(m),<span class="string">'Position'</span>,posU); <span class="keyword">end</span>
0639       <span class="keyword">end</span>
0640       
0641       <span class="comment">% set positions of buttons</span>
0642       nbtns = numel(handles.btns);
0643       w_allbtns = 2*Options.Sep*(nbtns-1) + nbtns*sinfo.w_btns;
0644       pos = [workarea(1) + (btnarea(3) - w_allbtns)/2, workarea(2), sinfo.w_btns, sinfo.h_btns];
0645       <span class="keyword">for</span> n = 1:nbtns
0646          set(handles.btns(n),<span class="string">'Position'</span>,pos);
0647          pos(1) = pos(1) + sinfo.w_btns + 2*Options.Sep;
0648       <span class="keyword">end</span>
0649    <span class="keyword">end</span>
0650 
0651 <span class="keyword">end</span>
0652 
0653 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0654 <span class="comment">%%% BUILDGUI :: Builds the dialog box and returns handles</span>
0655 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0656 <a name="_sub1" href="#_subfunctions" class="code">function [handles,Formats,sinfo] = buildgui(Prompt,Unit,Title,Formats,Options)</a>
0657 
0658 DefaultSize.text = [0 0]; <span class="comment">% auto size (max width: 250)</span>
0659 DefaultSize.edit = [165 0]; <span class="comment">% auto size height (base:20)</span>
0660 DefaultSize.popupmenu = [0 20]; <span class="comment">% auto size width</span>
0661 DefaultSize.listbox = [0 0];   <span class="comment">% auto size</span>
0662 DefaultSize.togglebutton = [0 0]; <span class="comment">% auto size</span>
0663 DefaultSize.radiobutton = [0 0]; <span class="comment">% auto size</span>
0664 DefaultSize.checkbox = [0 18]; <span class="comment">% auto size width</span>
0665 DefaultSize.slider = [75 15];
0666 DefaultSize.pushbutton = [69 22];
0667 
0668 <span class="comment">% determine how to utilize 'none' space</span>
0669 <span class="comment">% Place all the elements at (0,0)</span>
0670 free = reshape(strcmp(<span class="string">'none'</span>,{Formats.type}),size(Formats)); <span class="comment">% location of empty block to be occupied by neighbor entry</span>
0671 num = sum(~free(:)); <span class="comment">% number of controls</span>
0672 dim = size(Formats); <span class="comment">% display grid dimension</span>
0673 map = zeros(dim); <span class="comment">% determine which control occupies which block(s)</span>
0674 order = zeros(1,num); <span class="comment">% uicontrol placement order</span>
0675 n = 1;
0676 <span class="keyword">for</span> f = 1:prod(dim)
0677    <span class="comment">% traverse row-first</span>
0678    [j,i] = ind2sub(dim([2 1]),f);
0679    m = sub2ind(dim,i,j);
0680    
0681    <span class="keyword">if</span> free(m)
0682       mode = diff(Formats(m).limits);
0683       [i,j] = ind2sub(dim,m);
0684       <span class="keyword">if</span> mode&gt;0 &amp;&amp; j&gt;1, map(m) = map(sub2ind(dim,i,j-1)); <span class="comment">% left</span>
0685       <span class="keyword">elseif</span> mode&lt;0 &amp;&amp; i&gt;1, map(m) = map(sub2ind(dim,i-1,j)); <span class="comment">% above</span>
0686       <span class="keyword">end</span> <span class="comment">% other wise, 0 (nothing occupying)</span>
0687    <span class="keyword">else</span>
0688       map(m) = n;
0689       order(n) = m;
0690       n = n + 1;
0691    <span class="keyword">end</span>
0692 <span class="keyword">end</span>
0693 
0694 <span class="comment">% remove none's from Formats and order the rest in Prompt order</span>
0695 Formats = Formats(order);
0696 
0697 <span class="comment">% assign default size if Formats.size is non-positive</span>
0698 autosize = false(num,2);
0699 autoextend = false(num,2);
0700 <span class="keyword">for</span> m = 1:num
0701    autoextend(m,:) = Formats(m).size&lt;0;
0702    
0703    <span class="comment">% get default size if size not specified</span>
0704    <span class="keyword">if</span> Formats(m).size(1) &lt;=0
0705       Formats(m).size(1) = DefaultSize.(Formats(m).style)(1);
0706    <span class="keyword">end</span>
0707    <span class="keyword">if</span> Formats(m).size(2) &lt;=0
0708       Formats(m).size(2) = DefaultSize.(Formats(m).style)(2);
0709    <span class="keyword">end</span>
0710    
0711    <span class="comment">% if fixed size, turn autosize off</span>
0712    autosize(m,:) = Formats(m).size&lt;=0;
0713 <span class="keyword">end</span>
0714 
0715 
0716 FigColor=get(0,<span class="string">'DefaultUicontrolBackgroundcolor'</span>);
0717 
0718 fig = dialog(           <span class="keyword">...</span>
0719    <span class="string">'Visible'</span>     ,<span class="string">'off'</span>   , <span class="keyword">...</span>
0720    <span class="string">'Name'</span>       ,Title   , <span class="keyword">...</span>
0721    <span class="string">'Pointer'</span>     ,<span class="string">'arrow'</span>  , <span class="keyword">...</span>
0722    <span class="string">'Units'</span>      ,<span class="string">'pixels'</span>  , <span class="keyword">...</span>
0723    <span class="string">'UserData'</span>     ,<span class="string">'Cancel'</span>  , <span class="keyword">...</span>
0724    <span class="string">'Tag'</span>       ,<span class="string">'Figure'</span>   , <span class="keyword">...</span>
0725    <span class="string">'HandleVisibility'</span> ,<span class="string">'on'</span> , <span class="keyword">...</span>
0726    <span class="string">'Color'</span>      ,FigColor  , <span class="keyword">...</span>
0727    <span class="string">'NextPlot'</span>     ,<span class="string">'add'</span>   , <span class="keyword">...</span>
0728    <span class="string">'WindowStyle'</span>   ,Options.WindowStyle, <span class="keyword">...</span>
0729    <span class="string">'DoubleBuffer'</span>   ,<span class="string">'on'</span>    , <span class="keyword">...</span>
0730    <span class="string">'Resize'</span>      ,Options.Resize    <span class="keyword">...</span>
0731    );
0732 
0733 figSize = get(fig,<span class="string">'Position'</span>);
0734 
0735 <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0736 <span class="comment">%%% Set Positions %%%</span>
0737 <span class="comment">%%%%%%%%%%%%%%%%%%%%%</span>
0738 CommonInfo = {<span class="string">'Units'</span>  <span class="string">'pixels'</span>;
0739    <span class="string">'FontSize'</span>      get(0,<span class="string">'FactoryUIControlFontSize'</span>);
0740    <span class="string">'HandleVisibility'</span>  <span class="string">'callback'</span>}';
0741 
0742 props.edit = [CommonInfo {<span class="keyword">...</span>
0743    <span class="string">'FontWeight'</span>   get(fig,<span class="string">'DefaultUicontrolFontWeight'</span>);
0744    <span class="string">'Style'</span>      <span class="string">'edit'</span>;
0745    <span class="string">'HorizontalAlignment'</span> <span class="string">'left'</span>;
0746    <span class="string">'BackgroundColor'</span> <span class="string">'white'</span>}'];
0747 
0748 props.checkbox = [CommonInfo {<span class="keyword">...</span>
0749    <span class="string">'Style'</span>      <span class="string">'checkbox'</span>;
0750    <span class="string">'FontWeight'</span>   get(fig,<span class="string">'DefaultUicontrolFontWeight'</span>);
0751    <span class="string">'HorizontalAlignment'</span> <span class="string">'left'</span>;
0752    <span class="string">'BackgroundColor'</span> FigColor}'];
0753 
0754 props.popupmenu = [CommonInfo {<span class="keyword">...</span>
0755    <span class="string">'FontWeight'</span>   get(fig,<span class="string">'DefaultUicontrolFontWeight'</span>);
0756    <span class="string">'Style'</span>      <span class="string">'popupmenu'</span>;
0757    <span class="string">'HorizontalAlignment'</span> <span class="string">'left'</span>;
0758    <span class="string">'BackgroundColor'</span> <span class="string">'white'</span>}'];
0759 
0760 props.listbox = [CommonInfo {<span class="keyword">...</span>
0761    <span class="string">'FontWeight'</span>   get(fig,<span class="string">'DefaultUicontrolFontWeight'</span>);
0762    <span class="string">'Style'</span>      <span class="string">'listbox'</span>;
0763    <span class="string">'HorizontalAlignment'</span> <span class="string">'left'</span>;
0764    <span class="string">'BackgroundColor'</span> <span class="string">'white'</span>}'];
0765 
0766 props.slider = [CommonInfo {<span class="keyword">...</span>
0767    <span class="string">'Style'</span>      <span class="string">'slider'</span>;
0768    }'];
0769 
0770 props.uibuttongroup = [CommonInfo {<span class="keyword">...</span>
0771    <span class="string">'FontWeight'</span>   get(fig,<span class="string">'DefaultUicontrolFontWeight'</span>);
0772    <span class="string">'BackgroundColor'</span> FigColor;
0773    }'];
0774 
0775 props.radiobutton = props.checkbox;
0776 props.radiobutton{2,4} = <span class="string">'radiobutton'</span>;
0777 
0778 props.pushbutton = [CommonInfo {<span class="keyword">...</span>
0779    <span class="string">'Style'</span>        <span class="string">'pushbutton'</span>;
0780    <span class="string">'FontWeight'</span>     get(fig,<span class="string">'DefaultUicontrolFontWeight'</span>);
0781    <span class="string">'HorizontalAlignment'</span> <span class="string">'center'</span>}'];
0782 
0783 props.togglebutton = props.pushbutton;
0784 props.togglebutton{2,4} = <span class="string">'togglebutton'</span>;
0785 
0786 <span class="comment">% Add VerticalAlignment here as it is not applicable to the above.</span>
0787 TextInfo = [CommonInfo {<span class="keyword">...</span>
0788    <span class="string">'BackgroundColor'</span>   FigColor;
0789    <span class="string">'HorizontalAlignment'</span> <span class="string">'left'</span>;
0790    <span class="string">'VerticalAlignment'</span>  <span class="string">'bottom'</span>;
0791    <span class="string">'Color'</span>        get(0,<span class="string">'FactoryUIControlForegroundColor'</span>);
0792    <span class="string">'Interpreter'</span>     Options.Interpreter}'];
0793 
0794 <span class="comment">% Place the container (UIPANEL &amp; AXES) for the elements (for the ease of</span>
0795 <span class="comment">% resizing)</span>
0796 ax = axes(<span class="string">'Parent'</span>,fig,<span class="string">'Units'</span>,<span class="string">'pixels'</span>,<span class="string">'Visible'</span>,<span class="string">'off'</span>,<span class="keyword">...</span>
0797    <span class="string">'Position'</span>,[0 0 figSize(3:4)],<span class="string">'XLim'</span>,[0 figSize(3)],<span class="string">'YLim'</span>,[0 figSize(4)]);
0798 
0799 hPrompt = zeros(num,1);
0800 hEdit = zeros(num,1);
0801 hUnit = zeros(num,1);
0802 Cwidth = zeros(num,1);
0803 Cheight = zeros(num,1);
0804 Lwidth = zeros(num,1);
0805 Lheight = zeros(num,1);
0806 Uwidth = zeros(num,1);
0807 Uheight = zeros(num,1);
0808 CLoffset = zeros(num,1);
0809 CUoffset = zeros(num,1);
0810 <span class="keyword">for</span> m = 1:num
0811    Formats(m).size(autosize(m,:)) = 1; <span class="comment">% temporary width</span>
0812    
0813    idx = strcmp(Formats(m).style,{<span class="string">'radiobutton'</span>,<span class="string">'togglebutton'</span>});
0814    <span class="keyword">if</span> any(idx)
0815       <span class="comment">% create the UI Button Group object</span>
0816       hEdit(m) = uibuttongroup(<span class="string">'Parent'</span>,fig,props.uibuttongroup{:},<span class="keyword">...</span>
0817          <span class="string">'Position'</span>,[0 0 Formats(m).size],<span class="string">'Title'</span>,Prompt{m});
0818       
0819       <span class="keyword">if</span> idx(1),margin = [15 0]; <span class="comment">% radiobutton</span>
0820       <span class="keyword">else</span> margin = [10 2]; <span class="keyword">end</span> <span class="comment">% togglebutton</span>
0821       
0822       num_btns = numel(Formats(m).items);
0823       dim_btns = size(Formats(m).items);
0824       hButtons = zeros(dim_btns);
0825       btn_w = zeros(dim_btns);
0826       btn_h = zeros(dim_btns);
0827       <span class="keyword">for</span> k = 1:num_btns
0828          [j,i] = ind2sub(dim_btns([2 1]),k);
0829          <span class="keyword">if</span> isempty(Formats(m).items{i,j}), <span class="keyword">continue</span>; <span class="keyword">end</span> <span class="comment">% if empty string, no button at this position</span>
0830          hButtons(i,j) = uicontrol(<span class="string">'Parent'</span>,hEdit(m),<span class="string">'Style'</span>,Formats(m).style,props.(Formats(m).style){:},<span class="keyword">...</span>
0831             <span class="string">'String'</span>,Formats(m).items{i,j},<span class="string">'Min'</span>,0,<span class="string">'Max'</span>,1,<span class="string">'UserData'</span>,k);
0832          pos = get(hButtons(i,j),<span class="string">'Extent'</span>);
0833          btn_w(i,j) = pos(3);
0834          btn_h(i,j) = pos(4);
0835       <span class="keyword">end</span>
0836       
0837       set(hEdit(m),<span class="string">'UserData'</span>,hButtons);
0838       
0839       btn_w = btn_w + margin(1);
0840       btn_h = btn_h + margin(2);
0841       
0842       col_w = max(btn_w,[],1);
0843       row_h = max(btn_h,[],2);
0844       
0845       <span class="comment">% set positions of buttons</span>
0846       kvalid = find(hButtons~=0);
0847       <span class="keyword">for</span> k = reshape(kvalid,1,numel(kvalid))
0848          [i,j] = ind2sub(dim_btns,k); <span class="comment">% i-col, j-row</span>
0849          pos = [sum(col_w(1:j-1))+Options.Sep*j sum(row_h(i+1:end)) + Options.Sep*(dim_btns(1)-i+0.5) btn_w(k) btn_h(k)];
0850          set(hButtons(i,j),<span class="string">'Position'</span>,pos);
0851       <span class="keyword">end</span>
0852       
0853       Cwidth(m) = sum(col_w)+Options.Sep*(dim_btns(2)+1);
0854       Cheight(m) = sum(row_h)+Options.Sep*(dim_btns(1)+1);
0855       
0856       <span class="comment">% no auto-extension</span>
0857       autoextend(m,:) = false;
0858    <span class="keyword">elseif</span> strcmp(Formats(m).type,<span class="string">'text'</span>) <span class="comment">% static text (no labels)</span>
0859       <span class="comment">% create label</span>
0860       <span class="keyword">if</span> autosize(m,1) <span class="comment">% if not autosize, wrap as needed</span>
0861          str = Prompt{m};
0862       <span class="keyword">else</span>
0863          h = uicontrol(<span class="string">'Parent'</span>,fig,<span class="string">'Style'</span>,<span class="string">'text'</span>,<span class="string">'Position'</span>,[0 0 Formats(m).size]);
0864          msg = textwrap(h,Prompt(m));
0865          delete(h);
0866          str = msg{1};
0867          <span class="keyword">for</span> n = 2:length(msg)
0868             str = sprintf(<span class="string">'%s\n%s'</span>,str,msg{n});
0869          <span class="keyword">end</span>
0870       <span class="keyword">end</span>
0871       
0872       hPrompt(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,str);
0873       pos = get(hPrompt(m),<span class="string">'Extent'</span>);
0874       Lwidth(m) = pos(3);
0875       Lheight(m) = pos(4);
0876       Cheight(m) = pos(4);
0877       CLoffset(m) = 1;
0878    <span class="keyword">else</span>
0879       hEdit(m) = uicontrol(<span class="string">'Parent'</span>,fig,<span class="string">'Style'</span>,Formats(m).style,props.(Formats(m).style){:},<span class="keyword">...</span>
0880          <span class="string">'Position'</span>,[0 0 Formats(m).size]);
0881       
0882       Cwidth(m) = Formats(m).size(1);
0883       Cheight(m) = Formats(m).size(2);
0884       
0885       <span class="comment">% set min and max except for edit-text box</span>
0886       <span class="keyword">if</span> ~strcmp(Formats(m).style,<span class="string">'edit'</span>) || ~any(strcmp(Formats(m).format,{<span class="string">'float'</span>,<span class="string">'integer'</span>}))
0887          set(hEdit(m),<span class="string">'Min'</span>,Formats(m).limits(1),<span class="string">'Max'</span>,Formats(m).limits(2));
0888       <span class="keyword">end</span>
0889       
0890       <span class="keyword">switch</span> lower(Formats(m).style)
0891          <span class="keyword">case</span> <span class="string">'edit'</span>
0892             textmode = any(strcmp(Formats(m).format,{<span class="string">'text'</span>,<span class="string">'file'</span>}));
0893             <span class="keyword">if</span> autosize(m,2) <span class="comment">% auto-height</span>
0894                <span class="keyword">if</span> textmode
0895                   dlim = diff(Formats(m).limits);
0896                   <span class="keyword">if</span> (strcmp(Formats(m).format,<span class="string">'file'</span>) &amp;&amp; dlim&lt;1), dlim = 1; <span class="keyword">end</span>
0897                   Cheight(m) = 15*dlim + 5;
0898                <span class="keyword">else</span> <span class="comment">% numeric -&gt; force single-line</span>
0899                   Cheight(m) = 20;
0900                <span class="keyword">end</span>
0901                set(hEdit(m),<span class="string">'Position'</span>,[0 0 Formats(m).size]);
0902             <span class="keyword">end</span>
0903             
0904             <span class="comment">% If format is not text, reset Min &amp; Max to single-line mode</span>
0905             <span class="keyword">if</span> ~textmode, set(hEdit(m),<span class="string">'Min'</span>,0,<span class="string">'Max'</span>,1); <span class="keyword">end</span>
0906             
0907             <span class="comment">% create label</span>
0908             hPrompt(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Prompt{m});
0909             pos = get(hPrompt(m),<span class="string">'Extent'</span>);
0910             Lwidth(m) = pos(3); <span class="comment">% label element width</span>
0911             Lheight(m) = pos(4); <span class="comment">% label element height</span>
0912             
0913             <span class="keyword">if</span> ~isempty(Unit{m})
0914                hUnit(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Unit{m});
0915                pos = get(hUnit(m),<span class="string">'Extent'</span>);
0916                Uwidth(m) = pos(3)+2; <span class="comment">% label element width</span>
0917                Uheight(m) = pos(4); <span class="comment">% label element height</span>
0918             <span class="keyword">end</span>
0919             
0920             <span class="comment">% Align label with the editbox text location</span>
0921             <span class="comment">% editbox first-line text location varies depending on single- or multi-line mode</span>
0922             multline = textmode &amp;&amp; diff(Formats(m).limits)&gt;1;
0923             <span class="keyword">if</span> multline
0924                CLoffset(m) = 3 + Cheight(m) - Lheight(m);
0925                CUoffset(m) = 3 + Cheight(m) - Uheight(m);
0926             <span class="keyword">else</span>
0927                CLoffset(m) = 3 + (Cheight(m) - Lheight(m))/2;
0928                CUoffset(m) = 3 + (Cheight(m) - Uheight(m))/2;
0929             <span class="keyword">end</span>
0930             
0931             <span class="comment">% height auto-extension posible only if multiline</span>
0932             autoextend(m,2) = autoextend(m,2) &amp;&amp; multline;
0933             
0934             <span class="keyword">if</span> strcmp(Formats(m).format,<span class="string">'file'</span>) &amp;&amp; diff(Formats(m).limits)&gt;1
0935                set(hEdit(m),<span class="string">'UserData'</span>,{<span class="string">''</span> <span class="string">''</span>});
0936             <span class="keyword">end</span>
0937          <span class="keyword">case</span> <span class="string">'checkbox'</span> <span class="comment">% no labels</span>
0938             <span class="keyword">if</span> autosize(m,1) <span class="comment">% auto-width</span>
0939                set(hEdit(m),<span class="string">'String'</span>,Prompt{m});
0940                pos = get(hEdit(m),<span class="string">'Extent'</span>);
0941                pos(3) = pos(3) + 15;
0942                Cwidth(m) = pos(3);<span class="comment">%Formats(m).size(1) = pos(3);</span>
0943                set(hEdit(m),<span class="string">'Position'</span>,pos);
0944             <span class="keyword">end</span>
0945             
0946             <span class="comment">% width auto-extension possible only if width too short</span>
0947             autoextend(m,2) = false; <span class="comment">% no height auto-extend</span>
0948          <span class="keyword">case</span> <span class="string">'popupmenu'</span>
0949             <span class="comment">% force the height</span>
0950             Cheight(m) = DefaultSize.popupmenu(2);
0951             
0952             <span class="comment">% get the width of the widest entry</span>
0953             <span class="keyword">if</span> autosize(m,1) <span class="comment">% auto-width</span>
0954                <span class="keyword">for</span> itm = 1:numel(Formats(m).items)
0955                   set(hEdit(m),<span class="string">'String'</span>,Formats(m).items{itm},<span class="string">'Value'</span>,1);
0956                   p = get(hEdit(m),<span class="string">'Extent'</span>);
0957                   <span class="keyword">if</span> p(3)&gt;Cwidth(m), Cwidth(m) = p(3); <span class="keyword">end</span>
0958                <span class="keyword">end</span>
0959                Cwidth(m) = Cwidth(m) + 19;
0960             <span class="keyword">end</span>
0961             
0962             <span class="comment">% re-set position</span>
0963             set(hEdit(m),<span class="string">'Position'</span>,[0 0 Cwidth(m) Cheight(m)]);
0964             
0965             <span class="comment">% set menu &amp; choose the first entry</span>
0966             set(hEdit(m),<span class="string">'String'</span>,Formats(m).items',<span class="string">'Value'</span>,1);
0967             
0968             <span class="comment">% create label</span>
0969             hPrompt(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Prompt{m});
0970             pos = get(hPrompt(m),<span class="string">'Extent'</span>);
0971             Lwidth(m) = pos(3); <span class="comment">% label element width</span>
0972             Lheight(m) = pos(4); <span class="comment">% label element height</span>
0973             
0974             <span class="keyword">if</span> ~isempty(Unit{m})
0975                hUnit(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Unit{m});
0976                pos = get(hUnit(m),<span class="string">'Extent'</span>);
0977                Uwidth(m) = pos(3)+2; <span class="comment">% label element width</span>
0978                Uheight(m) = pos(4); <span class="comment">% label element height</span>
0979             <span class="keyword">end</span>
0980             
0981             <span class="comment">% Align label with the editbox text location</span>
0982             <span class="comment">% editbox first-line text location varies depending on single- or multi-line mode</span>
0983             CLoffset(m) = 1 + Cheight(m) - Lheight(m);
0984             CUoffset(m) = 1 + Cheight(m) - Uheight(m);
0985             
0986             <span class="comment">% width auto-extension possible only if width too short</span>
0987             autoextend(m,2) = false; <span class="comment">% no height auto-extend</span>
0988          <span class="keyword">case</span> <span class="string">'listbox'</span>
0989             <span class="comment">% get the max extent</span>
0990             pos = [0 0 0 0];
0991             <span class="keyword">for</span> itm = 1:numel(Formats(m).items)
0992                set(hEdit(m),<span class="string">'String'</span>,Formats(m).items{itm},<span class="string">'Value'</span>,1);
0993                p = get(hEdit(m),<span class="string">'Extent'</span>);
0994                <span class="keyword">if</span> p(3)&gt;pos(3), pos(3) = p(3); <span class="keyword">end</span>
0995             <span class="keyword">end</span>
0996             pos(3) = pos(3) + 19;
0997             pos(4) = 13*numel(Formats(m).items)+2;
0998             
0999             <span class="comment">% auto-size &amp; set autoextend</span>
1000             <span class="keyword">if</span> autosize(m,1), Cwidth(m) = pos(3); <span class="keyword">end</span>
1001             <span class="keyword">if</span> autosize(m,2), Cheight(m) = pos(4); <span class="keyword">end</span>
1002             <span class="keyword">if</span> any(autosize(m,:)), set(hEdit(m),<span class="string">'Position'</span>,pos); <span class="keyword">end</span>
1003             
1004             <span class="comment">% set table &amp; leave it unselected</span>
1005             <span class="keyword">if</span> diff(Formats(m).limits)&gt;1, val = [];
1006             <span class="keyword">else</span> val = 1; <span class="keyword">end</span>
1007             set(hEdit(m),<span class="string">'String'</span>,Formats(m).items',<span class="string">'Value'</span>,val);
1008             
1009             <span class="comment">% create label</span>
1010             hPrompt(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Prompt{m});
1011             pos = get(hPrompt(m),<span class="string">'Extent'</span>);
1012             Lwidth(m) = pos(3); <span class="comment">% label element width</span>
1013             Lheight(m) = pos(4); <span class="comment">% label element height</span>
1014             
1015             <span class="keyword">if</span> ~isempty(Unit{m})
1016                hUnit(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Unit{m});
1017                pos = get(hUnit(m),<span class="string">'Extent'</span>);
1018                Uwidth(m) = pos(3)+2; <span class="comment">% label element width</span>
1019                Uheight(m) = pos(4); <span class="comment">% label element height</span>
1020             <span class="keyword">end</span>
1021             
1022             <span class="comment">% Align label with the editbox text location</span>
1023             <span class="comment">% editbox first-line text location varies depending on single- or multi-line mode</span>
1024             CLoffset(m) = Cheight(m)-12;
1025             CUoffset(m) = Cheight(m)-12;
1026             
1027          <span class="keyword">case</span> <span class="string">'slider'</span>
1028             <span class="comment">% set slider initial value</span>
1029             val = mean(Formats(m).limits);
1030             set(hEdit(m),<span class="string">'Value'</span>,val,<span class="string">'TooltipString'</span>,num2str(val),<span class="string">'Callback'</span>,@(hObj,evt)set(hObj,<span class="string">'TooltipString'</span>,num2str(get(hObj,<span class="string">'Value'</span>))));
1031             
1032             <span class="comment">% create label</span>
1033             hPrompt(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Prompt{m});
1034             pos = get(hPrompt(m),<span class="string">'Extent'</span>);
1035             Lwidth(m) = pos(3); <span class="comment">% label element width</span>
1036             Lheight(m) = pos(4); <span class="comment">% label element height</span>
1037             
1038             <span class="keyword">if</span> ~isempty(Unit{m})
1039                hUnit(m) = text(<span class="string">'Parent'</span>,ax,TextInfo{:},<span class="string">'Position'</span>,[0,0],<span class="string">'String'</span>,Unit{m});
1040                pos = get(hUnit(m),<span class="string">'Extent'</span>);
1041                Uwidth(m) = pos(3)+2; <span class="comment">% label element width</span>
1042                Uheight(m) = pos(4); <span class="comment">% label element height</span>
1043             <span class="keyword">end</span>
1044             <span class="comment">% Align label with the editbox text location</span>
1045             <span class="comment">% editbox first-line text location varies depending on single- or multi-line mode</span>
1046             CLoffset(m) = (Formats(m).size(2) - Lheight(m))/2 + 4;
1047             CUoffset(m) = (Formats(m).size(2) - Uheight(m))/2 + 4;
1048             
1049             <span class="comment">% only resizable in the direction of slider</span>
1050             <span class="keyword">if</span> diff(Formats(m).size)&gt;=0, autoextend(m,2) = false;
1051             <span class="keyword">else</span> autoextend(m,1) = false; <span class="keyword">end</span>
1052       <span class="keyword">end</span>
1053    <span class="keyword">end</span>
1054 <span class="keyword">end</span>
1055 
1056 hBtn(1) = uicontrol(fig,props.pushbutton{:},<span class="string">'String'</span>,<span class="string">'OK'</span>,<span class="keyword">...</span>
1057    <span class="string">'Position'</span>,[0 0 DefaultSize.pushbutton]);
1058 hBtn(2) = uicontrol(fig,props.pushbutton{:},<span class="string">'String'</span>,<span class="string">'Cancel'</span>,<span class="keyword">...</span>
1059    <span class="string">'Position'</span>,[0 0 DefaultSize.pushbutton]);
1060 <span class="keyword">if</span> strcmpi(Options.ApplyButton,<span class="string">'on'</span>)
1061    hBtn(3) = uicontrol(fig,props.pushbutton{:},<span class="string">'String'</span>,<span class="string">'Apply'</span>,<span class="keyword">...</span>
1062       <span class="string">'Position'</span>,[0 0 DefaultSize.pushbutton]);
1063 <span class="keyword">end</span>
1064 
1065 <span class="comment">% output handle struct</span>
1066 handles.fig = fig;
1067 handles.labels = hPrompt';
1068 handles.ctrl = hEdit';
1069 handles.units = hUnit';
1070 handles.btns = hBtn;
1071 
1072 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1073 
1074 <span class="comment">% determine the minimum figure size</span>
1075 w = Cwidth+Lwidth+Uwidth;
1076 h = max([Cheight,Lheight,Uheight],[],2);
1077 
1078 <span class="comment">% distribute width &amp; height according to map</span>
1079 width = zeros(size(map));
1080 height = zeros(size(map));
1081 <span class="keyword">for</span> n = 1:num
1082    idx = find(map==n);
1083    [i,j] = ind2sub(dim,idx);
1084    I = unique(i);
1085    J = unique(j);
1086    n_row = numel(I);
1087    n_col = numel(J);
1088    
1089    width(idx) = (w(n)-(n_col-1)*Options.Sep)/n_col;
1090    height(idx) = (h(n)-(n_row-1)*Options.Sep)/n_row;
1091 <span class="keyword">end</span>
1092 
1093 col_w = max(width,[],1);
1094 row_h = max(height,[],2);
1095 
1096 wmin_ctrls = sum(col_w) + Options.Sep*(dim(2)+1);
1097 hmin_ctrls = sum(row_h) + Options.Sep*(dim(1)+1);
1098 nbtns = numel(handles.btns);
1099 btns_w = nbtns*DefaultSize.pushbutton(1) + 2*(nbtns-1)*Options.Sep;
1100 btns_h = DefaultSize.pushbutton(2);
1101 
1102 figSize(3:4) = [max(wmin_ctrls,btns_w)+3*Options.Sep hmin_ctrls+btns_h+3*Options.Sep];
1103 
1104 set(fig,<span class="string">'Position'</span>,figSize);
1105 
1106 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1107 
1108 sinfo.minfigsize = figSize(3:4);  <span class="comment">% minimum figure size</span>
1109 sinfo.map = map;        <span class="comment">% uicontrol map</span>
1110 sinfo.autoextend = autoextend; <span class="comment">% auto-extend when resize (to use the full span of figure window)</span>
1111 sinfo.w_labels = Lwidth;    <span class="comment">% width of labels</span>
1112 sinfo.w_ctrls = Cwidth;    <span class="comment">% width of controls</span>
1113 sinfo.w_units = Uwidth;
1114 sinfo.h_labels = Lheight;   <span class="comment">% height of labels</span>
1115 sinfo.h_ctrls = Cheight;    <span class="comment">% height of controls</span>
1116 sinfo.h_units = Uheight;
1117 sinfo.CLoffset = CLoffset;   <span class="comment">% label y offset w.r.t. control</span>
1118 sinfo.CUoffset = CUoffset;
1119 sinfo.w_btns = DefaultSize.pushbutton(1);
1120 sinfo.h_btns = DefaultSize.pushbutton(2);
1121 
1122 <span class="keyword">end</span>
1123 
1124 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1125 <span class="comment">%%% CHECKPROMPT :: Check Prompt input is valid &amp; fill default values</span>
1126 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1127 <a name="_sub2" href="#_subfunctions" class="code">function [Prompt,FieldNames,Units,err] = checkprompt(Prompt)</a>
1128 
1129 <span class="comment">% default configuration</span>
1130 FieldNames = {}; <span class="comment">% answer in a cell</span>
1131 Units = {}; <span class="comment">% no units</span>
1132 
1133 <span class="comment">% standard error</span>
1134 err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Prompt must be a cell string with up to three columns.'</span>};
1135 
1136 <span class="keyword">if</span> isempty(Prompt), Prompt = {<span class="string">'Input:'</span>};
1137 <span class="keyword">elseif</span> ~iscell(Prompt), Prompt = cellstr(Prompt);
1138 <span class="keyword">end</span>
1139 
1140 [nrow,ncol] = size(Prompt);
1141 
1142 <span class="comment">% prompt given in a row -&gt; transpose</span>
1143 <span class="keyword">if</span> ncol&gt;3
1144    <span class="keyword">if</span> nrow&lt;3, Prompt = Prompt'; [nrow,ncol] = size(Prompt);
1145    <span class="keyword">else</span> <span class="keyword">return</span>; <span class="keyword">end</span>
1146 <span class="keyword">end</span>
1147 
1148 <span class="comment">% struct fields defined</span>
1149 <span class="keyword">if</span> ncol&gt;1 &amp;&amp; ~all(cellfun(<span class="string">'isempty'</span>,Prompt(:,2))), FieldNames = Prompt(:,2); <span class="keyword">end</span>
1150 
1151 <span class="comment">% unit labels defined</span>
1152 <span class="keyword">if</span> ncol&gt;2, Units = Prompt(:,3);
1153 <span class="keyword">else</span> Units = repmat({<span class="string">''</span>},nrow,1); <span class="keyword">end</span>
1154 
1155 <span class="comment">% return only the labels</span>
1156 Prompt = Prompt(:,1);
1157 
1158 err = {}; <span class="comment">% all cleared</span>
1159 
1160 <span class="keyword">end</span>
1161 
1162 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1163 <span class="comment">%%% CHECKFORMATS :: Check Formats input is valid &amp; fill default values</span>
1164 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1165 <a name="_sub3" href="#_subfunctions" class="code">function [Formats,err] = checkformats(Formats,NumQuest)</a>
1166 
1167 fields  = [{<span class="string">'type'</span> <span class="string">'style'</span> <span class="string">'items'</span> <span class="string">'format'</span> <span class="string">'limits'</span>  <span class="string">'size'</span>};<span class="keyword">...</span>
1168    {<span class="string">'edit'</span> <span class="string">'edit'</span>  {<span class="string">''</span>}  <span class="string">'text'</span>  [0 1]   [0 0]}]; <span class="comment">% defaults</span>
1169 err = {};
1170 
1171 <span class="keyword">if</span> isempty(Formats)
1172    Formats = repmat(struct(fields{:}),NumQuest,1);
1173    <span class="keyword">return</span>
1174 <span class="keyword">end</span>
1175 
1176 <span class="comment">% backward compatibility (NumLines)</span>
1177 <span class="keyword">if</span> isnumeric(Formats)
1178    [rw,cl]=size(Formats);
1179    ok = rw==1;
1180    <span class="keyword">if</span> ok
1181       OneVect = ones(NumQuest,1);
1182       <span class="keyword">if</span> cl == 2, NumLines=Formats(OneVect,:);
1183       <span class="keyword">elseif</span> cl == 1, NumLines=Formats(OneVect);
1184       <span class="keyword">elseif</span> cl == NumQuest, NumLines = Formats';
1185       <span class="keyword">else</span> ok = false;
1186       <span class="keyword">end</span>
1187    <span class="keyword">end</span>
1188    <span class="keyword">if</span> rw == NumQuest &amp;&amp; any(cl == [1 2]), NumLines = Formats;
1189    <span class="keyword">elseif</span> ~ok
1190       err = {<span class="string">'MATLAB:inputdlg:IncorrectSize'</span>, <span class="string">'NumLines size is incorrect.'</span>};
1191       <span class="keyword">return</span>;
1192    <span class="keyword">end</span>
1193    
1194    <span class="comment">% set to default edit control (column stacked)</span>
1195    Formats = repmat(struct(fields{:}),NumQuest,1);
1196    
1197    <span class="comment">% set limits according to NumLines(:,1)</span>
1198    numlines = mat2cell([zeros(NumQuest,1) NumLines(:,1)],ones(NumQuest,1),2);
1199    [Formats.limits] = deal(numlines{:});
1200    
1201    <span class="comment">% sets the width to be 10*NumLines(:,2)</span>
1202    <span class="keyword">if</span> (size(NumLines,2) == 2)
1203       sizes = mat2cell([zeros(NumQuest,1) NumLines(:,2)],ones(NumQuest,1),2);
1204       [Formats.size] = deal(sizes{:});
1205    <span class="keyword">end</span>
1206    
1207    <span class="keyword">return</span>;
1208 <span class="keyword">elseif</span> ischar(Formats) || iscellstr(Formats) <span class="comment">% given type</span>
1209    <span class="keyword">if</span> ischar(Formats), Formats = cellstr(Formats); <span class="keyword">end</span>
1210    Formats = cell2struct(Formats,<span class="string">'type'</span>,3);
1211 <span class="keyword">elseif</span> ~isstruct(Formats)
1212    err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS must be an array of structure.'</span>};
1213    <span class="keyword">return</span>
1214 <span class="keyword">end</span>
1215 
1216 <span class="comment">% check fields</span>
1217 idx = find(~isfield(Formats,fields(1,:)));
1218 <span class="keyword">for</span> n = idx <span class="comment">% if does not exist, use default</span>
1219    [Formats.(fields{1,n})] = deal([]);
1220 <span class="keyword">end</span>
1221 
1222 <span class="comment">% set string fields to lower case</span>
1223 c = lower(cellfun(@char,{Formats.type},<span class="string">'UniformOutput'</span>,false));
1224 [Formats.type] = deal(c{:});
1225 c = lower(cellfun(@char,{Formats.style},<span class="string">'UniformOutput'</span>,false));
1226 [Formats.style] = deal(c{:});
1227 c = lower(cellfun(@char,{Formats.format},<span class="string">'UniformOutput'</span>,false));
1228 [Formats.format] = deal(c{:});
1229 
1230 <span class="comment">% check number of entries matching NumQuest (number of PROMPT elements)</span>
1231 <span class="keyword">if</span> sum(~strcmp(<span class="string">'none'</span>,{Formats.type})&amp;~strcmp(<span class="string">''</span>,{Formats.type}))~=NumQuest
1232    err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS must have matching number of elements to PROMPT (exluding ''none'' type).'</span>};
1233    <span class="keyword">return</span>
1234 <span class="keyword">end</span>
1235 
1236 <span class="comment">% check type field contents</span>
1237 <span class="keyword">if</span> ~isempty(setdiff({Formats.type},{<span class="string">'check'</span>,<span class="string">'edit'</span>,<span class="string">'list'</span>,<span class="string">'range'</span>,<span class="string">'text'</span>,<span class="string">'none'</span>,<span class="string">''</span>}))
1238    err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.type must be one of {''check'',''edit'',''list'',''range'',''none''}.'</span>};
1239    <span class="keyword">return</span>
1240 <span class="keyword">end</span>
1241 
1242 <span class="comment">% check format</span>
1243 <span class="keyword">if</span> ~isempty(setdiff({Formats.format},{<span class="string">'text'</span>,<span class="string">'float'</span>,<span class="string">'integer'</span>,<span class="string">'file'</span>,<span class="string">'dir'</span>,<span class="string">''</span>}))
1244    err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.format must be one of {''text'', ''float'', or ''integer''}.'</span>};
1245    <span class="keyword">return</span>
1246 <span class="keyword">end</span>
1247 
1248 num = numel(Formats);
1249 <span class="keyword">for</span> n = 1:num
1250    <span class="keyword">if</span> isempty(Formats(n).type), Formats(n).type = <span class="string">'none'</span>; <span class="keyword">end</span>
1251    
1252    <span class="keyword">switch</span> Formats(n).type
1253       <span class="keyword">case</span> <span class="string">'none'</span>
1254          <span class="keyword">if</span> isempty(Formats(n).limits), Formats(n).limits = [0 0]; <span class="keyword">end</span>
1255       <span class="keyword">case</span> <span class="string">'text'</span>
1256          <span class="keyword">if</span> isempty(Formats(n).style)
1257             Formats(n).style = <span class="string">'text'</span>;
1258          <span class="keyword">elseif</span> ~strcmp(Formats(n).style,<span class="string">'text'</span>);
1259             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.style for ''text'' type must be ''text''.'</span>};
1260             <span class="keyword">return</span>
1261          <span class="keyword">end</span>
1262       <span class="keyword">case</span> <span class="string">'check'</span>
1263          <span class="comment">% check style</span>
1264          <span class="keyword">if</span> isempty(Formats(n).style)
1265             Formats(n).style = <span class="string">'checkbox'</span>;
1266          <span class="keyword">elseif</span> ~strcmp(Formats(n).style,<span class="string">'checkbox'</span>)
1267             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.style for ''check'' type must be ''checkbox''.'</span>};
1268             <span class="keyword">return</span>
1269          <span class="keyword">end</span>
1270          
1271          <span class="comment">% check format</span>
1272          <span class="keyword">if</span> isempty(Formats(n).format)
1273             Formats(n).format = <span class="string">'integer'</span>;
1274          <span class="keyword">elseif</span> any(strcmp(Formats(n).format,{<span class="string">'text'</span>,<span class="string">'float'</span>}))
1275             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.format for ''check'' type must be either ''float'' or ''integer''.'</span>};
1276             <span class="keyword">return</span>
1277          <span class="keyword">end</span>
1278       <span class="keyword">case</span> <span class="string">'edit'</span>
1279          <span class="comment">% check style</span>
1280          <span class="keyword">if</span> isempty(Formats(n).style)
1281             Formats(n).style = <span class="string">'edit'</span>;
1282          <span class="keyword">elseif</span> ~strcmp(Formats(n).style,<span class="string">'edit'</span>)
1283             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.style for ''edit'' type must be ''edit''.'</span>};
1284             <span class="keyword">return</span>
1285          <span class="keyword">end</span>
1286          
1287          <span class="comment">% check format</span>
1288          <span class="keyword">if</span> isempty(Formats(n).format)
1289             Formats(n).format = <span class="string">'text'</span>;
1290          <span class="keyword">elseif</span> strcmp(Formats(n).format,<span class="string">'file'</span>) &amp;&amp; isempty(Formats(n).items)
1291             Formats(n).items = {<span class="string">'*.*'</span> <span class="string">'All Files'</span>};
1292          <span class="keyword">end</span>
1293       <span class="keyword">case</span> <span class="string">'list'</span>
1294          <span class="comment">% check style</span>
1295          <span class="keyword">if</span> isempty(Formats(n).style)
1296             Formats(n).style = <span class="string">'popupmenu'</span>;
1297          <span class="keyword">elseif</span> ~any(strcmp(Formats(n).style,{<span class="string">'listbox'</span>,<span class="string">'popupmenu'</span>,<span class="string">'radiobutton'</span>,<span class="string">'togglebutton'</span>}))
1298             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.style for ''list'' type must be either ''listbox'', ''popupmenu'', ''radiobutton'', or ''togglebutton''.'</span>};
1299             <span class="keyword">return</span>
1300          <span class="keyword">end</span>
1301          
1302          <span class="comment">% check items</span>
1303          <span class="keyword">if</span> isempty(Formats(n).items)
1304             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.items must contain strings for the ''list'' type.'</span>};
1305             <span class="keyword">return</span>
1306          <span class="keyword">end</span>
1307          <span class="keyword">if</span> ~iscell(Formats(n).items)
1308             <span class="keyword">if</span> ischar(Formats(n).items)
1309                Formats(n).items = cellstr(Formats(n).items);
1310             <span class="keyword">elseif</span> isnumeric(Formats(n).items)
1311                Formats(n).items = cellfun(@num2str,num2cell(Formats(n).items),<span class="string">'UniformOutput'</span>,false);
1312             <span class="keyword">else</span>
1313                err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.items must be either a cell of strings or of numbers.'</span>};
1314                <span class="keyword">return</span>
1315             <span class="keyword">end</span>
1316          <span class="keyword">end</span>
1317          
1318          <span class="comment">% check format</span>
1319          <span class="keyword">if</span> isempty(Formats(n).format)
1320             Formats(n).format = <span class="string">'integer'</span>;
1321          <span class="keyword">elseif</span> any(strcmp(Formats(n).format,{<span class="string">'text'</span>,<span class="string">'float'</span>}))
1322             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.format must be ''integer'' for the ''list'' type.'</span>};
1323             <span class="keyword">return</span>
1324          <span class="keyword">end</span>
1325       <span class="keyword">case</span> <span class="string">'range'</span>
1326          <span class="comment">% check style</span>
1327          <span class="keyword">if</span> isempty(Formats(n).style)
1328             Formats(n).style = <span class="string">'slider'</span>;
1329          <span class="keyword">elseif</span> ~strcmp(Formats(n).style,<span class="string">'slider'</span>)
1330             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.style for ''range'' type must be ''slider''.'</span>};
1331             <span class="keyword">return</span>
1332          <span class="keyword">end</span>
1333          
1334          <span class="keyword">if</span> isempty(Formats(n).format)
1335             Formats(n).format = <span class="string">'float'</span>;
1336          <span class="keyword">elseif</span> ~strcmp(Formats(n).format,<span class="string">'float'</span>)
1337             err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.format for ''range'' type must be ''float''.'</span>};
1338             <span class="keyword">return</span>
1339          <span class="keyword">end</span>
1340    <span class="keyword">end</span>
1341    
1342    <span class="comment">% check limits</span>
1343    <span class="keyword">if</span> isempty(Formats(n).limits)
1344       <span class="keyword">if</span> strcmp(Formats(n).style,<span class="string">'edit'</span>) &amp;&amp; any(strcmp(Formats(n).format,{<span class="string">'integer'</span>,<span class="string">'float'</span>}))
1345          Formats(n).limits = [-inf inf]; <span class="comment">% default for numeric edit box</span>
1346       <span class="keyword">else</span>
1347          Formats(n).limits = [0 1]; <span class="comment">% default for all other controls</span>
1348       <span class="keyword">end</span>
1349    <span class="keyword">else</span>
1350       <span class="keyword">if</span> ~isnumeric(Formats(n).limits) || ~any(numel(Formats(n).limits)==[1 2]) || any(isnan(Formats(n).limits)) <span class="keyword">...</span><span class="comment"> % 2-element numeric vector and cannot be NaN</span>
1351             || (~(strcmp(Formats(n).type,<span class="string">'check'</span>)||(strcmp(Formats(n).type,<span class="string">'edit'</span>)&amp;&amp;strcmp(Formats(n).format,<span class="string">'file'</span>))||strcmp(Formats(n).type,<span class="string">'none'</span>)) &amp;&amp; Formats(n).limits(1)&gt;=Formats(n).limits(2)) <span class="keyword">...</span><span class="comment"> % if not check or none, has to be increasing</span>
1352             || (~(strcmp(Formats(n).type,<span class="string">'edit'</span>) &amp;&amp; any(strcmp(Formats(n).format,{<span class="string">'float'</span>,<span class="string">'integer'</span>}))) &amp;&amp; any(isinf(Formats(n).limits))) <span class="comment">% if not edit-text, has to be finite</span>
1353          
1354          err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.limits must be increasing and non-NaN.'</span>};
1355          <span class="keyword">return</span>
1356       <span class="keyword">end</span>
1357       <span class="keyword">if</span> numel(Formats(n).limits)==1, Formats(n).limits(2) = 0; <span class="keyword">end</span>
1358    <span class="keyword">end</span>
1359    
1360    <span class="comment">% check size</span>
1361    <span class="keyword">if</span> isempty(Formats(n).size)
1362       Formats(n).size = [0 0]; <span class="comment">% default to auto-size</span>
1363    <span class="keyword">else</span>
1364       <span class="keyword">if</span> ~isnumeric(Formats(n).size) || ~any(numel(Formats(n).size)==[1 2]) || any(isnan(Formats(n).size))
1365          err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'FORMATS.size must be non-NaN.'</span>};
1366          <span class="keyword">return</span>
1367       <span class="keyword">end</span>
1368       <span class="keyword">if</span> numel(Formats(n).size)==1
1369          Formats(n).size(2) = 0;
1370       <span class="keyword">end</span>
1371    <span class="keyword">end</span>
1372    
1373 <span class="keyword">end</span>
1374 
1375 <span class="keyword">end</span>
1376 
1377 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1378 <span class="comment">%%% CHECKDEFAULTS :: Check the specified default values are compatible</span>
1379 <span class="comment">%%% with Formats and if one not given fill in an initial value</span>
1380 <a name="_sub4" href="#_subfunctions" class="code">function [DefAns,DefStr,err] = checkdefaults(DefAns,Formats,FieldNames)</a>
1381 
1382 DefStr = struct([]); <span class="comment">% struct not used</span>
1383 
1384 <span class="comment">% trim Formats to only include relevant entries (non-'none' types)</span>
1385 Formats = Formats'; <span class="comment">% go through row first</span>
1386 Formats = Formats(~strcmp(<span class="string">'none'</span>,{Formats.type}));
1387 len = numel(Formats);
1388 
1389 <span class="keyword">if</span> isempty(DefAns) <span class="comment">% if DefAns not given</span>
1390    DefAns = cell(len,1); <span class="comment">% will set DefAns to default values</span>
1391 <span class="keyword">elseif</span> isstruct(DefAns)
1392    <span class="keyword">if</span> isempty(FieldNames) <span class="comment">% struct return</span>
1393       err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Default answer given in a structure but the prompts do not have associated answer field names in the second column.'</span>};
1394       <span class="keyword">return</span>;
1395    <span class="keyword">end</span>
1396    <span class="keyword">if</span> ~all(isfield(DefAns,FieldNames)|cellfun(<span class="string">'isempty'</span>,FieldNames))
1397       err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Default answer structure is missing at least one answer field.'</span>};
1398       <span class="keyword">return</span>;
1399    <span class="keyword">end</span>
1400    DefStr = DefAns;
1401    DefAns = cell(len,1);
1402    <span class="keyword">for</span> k = 1:len
1403       <span class="keyword">if</span> ~isempty(FieldNames{k}), DefAns{k} = DefStr.(FieldNames{k}); <span class="keyword">end</span>
1404    <span class="keyword">end</span>
1405 <span class="keyword">elseif</span> ~iscell(DefAns)
1406    err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Default answer must be given in a cell array or a structure.'</span>};
1407    <span class="keyword">return</span>;
1408 <span class="keyword">elseif</span> length(DefAns)~=len
1409    err = {<span class="string">'inputsdlg:InvalidINput'</span>,<span class="string">'Default answer cell dimension disagrees with the number of prompt'</span>};
1410    <span class="keyword">return</span>;
1411 <span class="keyword">end</span>
1412 
1413 err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Default value is not consistent with Formats.'</span>};
1414 
1415 <span class="comment">% go through each default values</span>
1416 <span class="keyword">for</span> k = 1:len
1417    <span class="keyword">if</span> isempty(DefAns{k}) <span class="comment">% set non-empty default values</span>
1418       <span class="keyword">switch</span> Formats(k).type
1419          <span class="keyword">case</span> <span class="string">'check'</span> <span class="comment">% off</span>
1420             DefAns{k} = Formats(k).limits(1);
1421          <span class="keyword">case</span> <span class="string">'edit'</span>
1422             <span class="keyword">switch</span> Formats(k).format
1423                <span class="keyword">case</span> {<span class="string">'text'</span>,<span class="string">'file'</span>,<span class="string">'dir'</span>}
1424                   DefAns{k} = <span class="string">''</span>; <span class="comment">% change to empty string</span>
1425                <span class="keyword">case</span> {<span class="string">'float'</span>,<span class="string">'integer'</span>}
1426                   liminf = isinf(Formats(k).limits);
1427                   <span class="keyword">if</span> all(liminf) <span class="comment">% both limits inf</span>
1428                      DefAns{k} = 0;
1429                   <span class="keyword">elseif</span> any(liminf) <span class="comment">% 1 limit inf</span>
1430                      DefAns{k} = Formats(k).limits(~liminf);
1431                   <span class="keyword">else</span>
1432                      DefAns{k} = round(mean(Formats(k).limits));
1433                   <span class="keyword">end</span>
1434             <span class="keyword">end</span>
1435          <span class="keyword">case</span> <span class="string">'list'</span> <span class="comment">% first item</span>
1436             DefAns{k} = 1;
1437          <span class="keyword">case</span> <span class="string">'range'</span> <span class="comment">% middle value</span>
1438             DefAns{k} = mean(Formats(k).limits);
1439       <span class="keyword">end</span>
1440    <span class="keyword">else</span> <span class="comment">% check given values</span>
1441       msel = strcmp(Formats(k).style,<span class="string">'listbox'</span>) &amp;&amp; diff(Formats(k).limits)&gt;1;
1442       <span class="keyword">switch</span> Formats(k).format
1443          <span class="keyword">case</span> <span class="string">'text'</span>
1444             <span class="keyword">if</span> ~(isempty(DefAns{k}) || ischar(DefAns{k})), <span class="keyword">return</span>; <span class="keyword">end</span>
1445          <span class="keyword">case</span> <span class="string">'float'</span>
1446             <span class="keyword">if</span> ~isfloat(DefAns{k}) || numel(DefAns{k})~=1, <span class="keyword">return</span>; <span class="keyword">end</span>
1447          <span class="keyword">case</span> <span class="string">'integer'</span> <span class="comment">% can be multi-select if type=list</span>
1448             <span class="keyword">if</span> ~islogical(DefAns{k}) <span class="keyword">...</span>
1449                   &amp;&amp; (~isnumeric(DefAns{k}) || any(DefAns{k}~=floor(DefAns{k})) || (~msel &amp;&amp; numel(DefAns{k})~=1))
1450                <span class="keyword">return</span>;
1451             <span class="keyword">end</span>
1452          <span class="keyword">case</span> <span class="string">'file'</span>
1453             dlim = diff(Formats(k).limits);
1454             <span class="keyword">if</span> ~isempty(DefAns{k}) &amp;&amp; dlim&gt;=0 <span class="comment">% for uisetfile</span>
1455                <span class="keyword">if</span> dlim&lt;=1 <span class="comment">% single-file</span>
1456                   files = DefAns(k);
1457                <span class="keyword">else</span> <span class="comment">%dlim&gt;1 % multiple-files</span>
1458                   files = DefAns{k};
1459                <span class="keyword">end</span>
1460                <span class="keyword">for</span> n = 1:length(files)
1461                   d = dir(files{n});
1462                   <span class="keyword">if</span> ~isempty(files{n}) &amp;&amp; length(d)~=1
1463                      err{2} = <span class="string">'Default file name does not resolve to a unique file.'</span>;
1464                      <span class="keyword">return</span>;
1465                   <span class="keyword">end</span>
1466                <span class="keyword">end</span>
1467             <span class="keyword">end</span>
1468          <span class="keyword">case</span> <span class="string">'dir'</span>
1469             <span class="keyword">if</span> isempty(DefAns{k}) || ~isdir(DefAns{k})
1470                err{2} = <span class="string">'Default directory does nto exist.'</span>;
1471                <span class="keyword">return</span>;
1472             <span class="keyword">end</span>
1473       <span class="keyword">end</span>
1474       
1475       <span class="keyword">switch</span> Formats(k).type
1476          <span class="keyword">case</span> <span class="string">'check'</span> <span class="comment">% must be one of the values in limits</span>
1477             <span class="keyword">if</span> all(DefAns{k} ~= Formats(k).limits), <span class="keyword">return</span>; <span class="keyword">end</span>
1478          <span class="keyword">case</span> <span class="string">'edit'</span> <span class="comment">% if numeric, must be within the limits</span>
1479             <span class="keyword">if</span> any(strcmp(Formats(k).format,{<span class="string">'float'</span>,<span class="string">'integer'</span>})) <span class="keyword">...</span>
1480                   &amp;&amp; (DefAns{k}&lt;Formats(k).limits(1) || DefAns{k}&gt;Formats(k).limits(2))
1481                <span class="keyword">return</span>;
1482             <span class="keyword">end</span>
1483             
1484          <span class="keyword">case</span> <span class="string">'list'</span> <span class="comment">% has to be valid index to the list</span>
1485             <span class="keyword">if</span> any(DefAns{k}&lt;1) || any(DefAns{k}&gt;numel(Formats(k).items)), <span class="keyword">return</span>; <span class="keyword">end</span>
1486             
1487          <span class="keyword">case</span> <span class="string">'range'</span> <span class="comment">% has to be within the limits</span>
1488             <span class="keyword">if</span> DefAns{k}&lt;Formats(k).limits(1) || DefAns{k}&gt;Formats(k).limits(2)
1489                <span class="keyword">return</span>;
1490             <span class="keyword">end</span>
1491       <span class="keyword">end</span>
1492    <span class="keyword">end</span>
1493 <span class="keyword">end</span>
1494 
1495 <span class="comment">% also initialize DefStr if FieldNames given</span>
1496 <span class="keyword">if</span> isempty(DefStr) &amp;&amp; ~isempty(FieldNames)
1497    idx = ~cellfun(<span class="string">'isempty'</span>,FieldNames);
1498    StructArgs = [FieldNames(idx) DefAns(idx)]';
1499    DefStr = struct(StructArgs{:});
1500 <span class="keyword">end</span>
1501 
1502 err = {}; <span class="comment">% all good</span>
1503 <span class="keyword">end</span>
1504 
1505 <a name="_sub5" href="#_subfunctions" class="code">function [Options,err] = checkoptions(Options)</a>
1506 
1507 err = {<span class="string">'inputsdlg:InvalidInput'</span>,<span class="string">'Options must be ''on'', ''off'', or a struct.'</span>};
1508 
1509 Fields = {<span class="string">'Resize'</span>,   <span class="string">'off'</span>
1510    <span class="string">'WindowStyle'</span>, <span class="string">'normal'</span>
1511    <span class="string">'Interpreter'</span>, <span class="string">'tex'</span>
1512    <span class="string">'ApplyButton'</span>, <span class="string">'off'</span>
1513    <span class="string">'Sep'</span>,     10}';
1514 
1515 <span class="keyword">if</span> isempty(Options)
1516    Options = struct(Fields{:});
1517 <span class="keyword">elseif</span> ~isstruct(Options)
1518    <span class="keyword">if</span> ~(ischar(Options)||iscellstr(Options)), <span class="keyword">return</span>; <span class="keyword">end</span> <span class="comment">% must be struct or a string</span>
1519    Fields{2,1} = char(Options);
1520    Options = struct(Fields{:});
1521 <span class="keyword">end</span>
1522 
1523 <span class="keyword">if</span> ~isfield(Options,<span class="string">'Resize'</span>) || isempty(Options.Resize)
1524    Options.Resize = <span class="string">'off'</span>;
1525 <span class="keyword">elseif</span> ~strcmpi(Options.Resize,{<span class="string">'on'</span>,<span class="string">'off'</span>})
1526    err{2} = <span class="string">'Resize option must be ''on'' or ''off''.'</span>;
1527    <span class="keyword">return</span>;
1528 <span class="keyword">end</span>
1529 <span class="keyword">if</span> ~isfield(Options,<span class="string">'WindowStyle'</span>) || isempty(Options.WindowStyle)
1530    Options.WindowStyle = <span class="string">'normal'</span>;
1531 <span class="keyword">elseif</span> ~strcmpi(Options.WindowStyle,{<span class="string">'normal'</span>,<span class="string">'modal'</span>,<span class="string">'docked'</span>})
1532    err{2} = <span class="string">'WindowStyle option must be ''normal'' or ''modal''.'</span>;
1533    <span class="keyword">return</span>;
1534 <span class="keyword">end</span>
1535 <span class="keyword">if</span> ~isfield(Options,<span class="string">'Interpreter'</span>) || isempty(Options.Interpreter)
1536    Options.Interpreter = <span class="string">'tex'</span>;
1537 <span class="keyword">elseif</span> ~strcmpi(Options.Interpreter,{<span class="string">'latex'</span>,<span class="string">'tex'</span>,<span class="string">'none'</span>})
1538    err{2} = <span class="string">'Interpreter option must be ''latex'', ''tex'', or ''none''.'</span>;
1539    <span class="keyword">return</span>;
1540 <span class="keyword">end</span>
1541 <span class="keyword">if</span> ~isfield(Options,<span class="string">'ApplyButton'</span>) || isempty(Options.ApplyButton)
1542    Options.ApplyButton = <span class="string">'off'</span>;
1543 <span class="keyword">elseif</span> ~strcmpi(Options.ApplyButton,{<span class="string">'on'</span>,<span class="string">'off'</span>})
1544    err{2} = <span class="string">'ApplyButton option must be ''on'' or ''off''.'</span>;
1545    <span class="keyword">return</span>;
1546 <span class="keyword">end</span>
1547 <span class="keyword">if</span> ~isfield(Options,<span class="string">'Sep'</span>) || isempty(Options.Sep)
1548    Options.Sep = 10;
1549 <span class="keyword">elseif</span> ~isnumeric(Options.Sep) || Options.Sep&lt;0
1550    err{2} = <span class="string">'Sep option must be non-negative scalar value.'</span>;
1551    <span class="keyword">return</span>;
1552 <span class="keyword">end</span>
1553 
1554 err = {}; <span class="comment">% all cleared</span>
1555 <span class="keyword">end</span>
1556 
1557 <span class="comment">% Copyright (c)2009, Takeshi Ikuma</span>
1558 <span class="comment">% All rights reserved.</span>
1559 <span class="comment">%</span>
1560 <span class="comment">% Redistribution and use in source and binary forms, with or without</span>
1561 <span class="comment">% modification, are permitted provided that the following conditions are</span>
1562 <span class="comment">% met:</span>
1563 <span class="comment">%</span>
1564 <span class="comment">%   * Redistributions of source code must retain the above copyright</span>
1565 <span class="comment">%   notice, this list of conditions and the following disclaimer. *</span>
1566 <span class="comment">%   Redistributions in binary form must reproduce the above copyright</span>
1567 <span class="comment">%   notice, this list of conditions and the following disclaimer in the</span>
1568 <span class="comment">%   documentation and/or other materials provided with the distribution.</span>
1569 <span class="comment">%   * Neither the name of the &lt;ORGANIZATION&gt; nor the names of its</span>
1570 <span class="comment">%   contributors may be used to endorse or promote products derived from</span>
1571 <span class="comment">%   this software without specific prior written permission.</span>
1572 <span class="comment">%</span>
1573 <span class="comment">% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
1574 <span class="comment">% IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span>
1575 <span class="comment">% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
1576 <span class="comment">% PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR</span>
1577 <span class="comment">% CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
1578 <span class="comment">% EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
1579 <span class="comment">% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
1580 <span class="comment">% PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
1581 <span class="comment">% LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
1582 <span class="comment">% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
1583 <span class="comment">% SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></pre></div>
<hr><address>Generated on Wed 27-Oct-2010 20:01:59 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>