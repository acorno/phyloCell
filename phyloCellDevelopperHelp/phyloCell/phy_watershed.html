<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of phy_watershed</title>
  <meta name="keywords" content="phy_watershed">
  <meta name="description" content="WATERSHED Watershed transform.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- # phyloCell -->
<h1>phy_watershed
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>WATERSHED Watershed transform.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function L = phy_watershed(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">WATERSHED Watershed transform.
   L = WATERSHED(A) computes a label matrix identifying the watershed
   regions of the input matrix A.  A can have any dimension.  The elements
   of L are integer values greater than or equal to 0.  The elements
   labeled 0 do not belong to a unique watershed region.  These are called
   &quot;watershed pixels.&quot;  The elements labeled 1 belong to the first
   watershed region, the elements labeled 2 belong to the second watershed
   region, and so on.

   By default, WATERSHED uses 8-connected neighborhoods for 2-D inputs
   and 26-connected neighborhoods for 3-D inputs.  For higher
   dimensions, WATERSHED uses the connectivity given by
   CONNDEF(NDIMS(A),'maximal').

   L = WATERSHED(A,CONN) computes the watershed transform using the
   specified connectivity.  CONN may have the following scalar values:

       4     two-dimensional four-connected neighborhood
       8     two-dimensional eight-connected neighborhood
       6     three-dimensional six-connected neighborhood
       18    three-dimensional 18-connected neighborhood
       26    three-dimensional 26-connected neighborhood

   Connectivity may be defined in a more general way for any dimension by
   using for CONN a 3-by-3-by- ... -by-3 matrix of 0s and 1s.  The 1-valued
   elements define neighborhood locations relative to the center element of
   CONN.  If specified this way, CONN must be symmetric about its center.

   Note
   ----
   The watershed transform algorithm used by this function changed in
   version 5.4 (R2007a) of the Image Processing Toolbox.  The previous 
   algorithm occasionally produced labeled watershed basins that were not
   contiguous.  If you need to obtain the same results as the previous
   algorithm, use the function WATERSHED_OLD.

   Class Support
   -------------
   A can be a numeric or logical array of any dimension, and it must be
   nonsparse.  The output array L is double. 

   Example (2-D)
   -------------
   1. Make a binary image containing two overlapping circular objects.

       center1 = -10;
       center2 = -center1;
       dist = sqrt(2*(2*center1)^2);
       radius = dist/2 * 1.4;
       lims = [floor(center1-1.2*radius) ceil(center2+1.2*radius)];
       [x,y] = meshgrid(lims(1):lims(2));
       bw1 = sqrt((x-center1).^2 + (y-center1).^2) &lt;= radius;
       bw2 = sqrt((x-center2).^2 + (y-center2).^2) &lt;= radius;
       bw = bw1 | bw2;
       figure, imshow(bw,'InitialMagnification','fit'), title('bw')

   2. Compute the distance transform of the complement of the binary
      image. 

       D = bwdist(~bw);
       figure, imshow(D,[],'InitialMagnification','fit')
       title('Distance transform of ~bw')

   3. Complement the distance transform, and force pixels that don't
      belong to the objects to be at -Inf.

       D = -D;
       D(~bw) = -Inf;

   4. Compute the watershed transform, and display the resulting label
      matrix as an RGB image.

       L = watershed(D); 
       rgb = label2rgb(L,'jet',[.5 .5 .5]);
       figure, imshow(rgb,'InitialMagnification','fit')
       title('Watershed transform of D')

   Example (3-D)
   -------------
   1. Make a 3-D binary image containing two overlapping spheres.

       center1 = -10;
       center2 = -center1;
       dist = sqrt(3*(2*center1)^2);
       radius = dist/2 * 1.4;
       lims = [floor(center1-1.2*radius) ceil(center2+1.2*radius)];
       [x,y,z] = meshgrid(lims(1):lims(2));
       bw1 = sqrt((x-center1).^2 + (y-center1).^2 + ...
           (z-center1).^2) &lt;= radius;
       bw2 = sqrt((x-center2).^2 + (y-center2).^2 + ...
           (z-center2).^2) &lt;= radius;
       bw = bw1 | bw2;
       figure, isosurface(x,y,z,bw,0.5), axis equal, title('BW')
       xlabel x, ylabel y, zlabel z
       xlim(lims), ylim(lims), zlim(lims)
       view(3), camlight, lighting gouraud

   2. Compute the distance transform.

       D = bwdist(~bw);
       figure, isosurface(x,y,z,D,radius/2), axis equal
       title('Isosurface of distance transform')
       xlabel x, ylabel y, zlabel z
       xlim(lims), ylim(lims), zlim(lims)
       view(3), camlight, lighting gouraud

   3. Complement the distance transform, force nonobject pixels to be
      -Inf, and then compute the watershed transform.

       D = -D;
       D(~bw) = -Inf;
       L = watershed(D);
       figure, isosurface(x,y,z,L==2,0.5), axis equal
       title('Segmented object')
       xlabel x, ylabel y, zlabel z
       xlim(lims), ylim(lims), zlim(lims)
       view(3), camlight, lighting gouraud
       figure, isosurface(x,y,z,L==3,0.5), axis equal
       title('Segmented object')
       xlabel x, ylabel y, zlabel z
       xlim(lims), ylim(lims), zlim(lims)
       view(3), camlight, lighting gouraud

   See also BWLABEL, BWLABELN, REGIONPROPS, WATERSHED_OLD.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="phy_segmentBudneck.html" class="code" title="function [budneck]=phy_segmentBudneck(img,parametres)">phy_segmentBudneck</a>	segment budneck function</li><li><a href="phy_segmentCellsWatershed.html" class="code" title="function cells2=phy_segmentCellsWatershed(imdata,parametres)">phy_segmentCellsWatershed</a>	segment cells with watershed method</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function L = local_bwlabel(BW, conn)</a></li><li><a href="#_sub2" class="code">function tf = is4Conn(conn)</a></li><li><a href="#_sub3" class="code">function tf = is8Conn(conn)</a></li><li><a href="#_sub4" class="code">function [A,conn] = parse_inputs(varargin)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function L = phy_watershed(varargin)</a>
0002 <span class="comment">%WATERSHED Watershed transform.</span>
0003 <span class="comment">%   L = WATERSHED(A) computes a label matrix identifying the watershed</span>
0004 <span class="comment">%   regions of the input matrix A.  A can have any dimension.  The elements</span>
0005 <span class="comment">%   of L are integer values greater than or equal to 0.  The elements</span>
0006 <span class="comment">%   labeled 0 do not belong to a unique watershed region.  These are called</span>
0007 <span class="comment">%   &quot;watershed pixels.&quot;  The elements labeled 1 belong to the first</span>
0008 <span class="comment">%   watershed region, the elements labeled 2 belong to the second watershed</span>
0009 <span class="comment">%   region, and so on.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   By default, WATERSHED uses 8-connected neighborhoods for 2-D inputs</span>
0012 <span class="comment">%   and 26-connected neighborhoods for 3-D inputs.  For higher</span>
0013 <span class="comment">%   dimensions, WATERSHED uses the connectivity given by</span>
0014 <span class="comment">%   CONNDEF(NDIMS(A),'maximal').</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   L = WATERSHED(A,CONN) computes the watershed transform using the</span>
0017 <span class="comment">%   specified connectivity.  CONN may have the following scalar values:</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%       4     two-dimensional four-connected neighborhood</span>
0020 <span class="comment">%       8     two-dimensional eight-connected neighborhood</span>
0021 <span class="comment">%       6     three-dimensional six-connected neighborhood</span>
0022 <span class="comment">%       18    three-dimensional 18-connected neighborhood</span>
0023 <span class="comment">%       26    three-dimensional 26-connected neighborhood</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%   Connectivity may be defined in a more general way for any dimension by</span>
0026 <span class="comment">%   using for CONN a 3-by-3-by- ... -by-3 matrix of 0s and 1s.  The 1-valued</span>
0027 <span class="comment">%   elements define neighborhood locations relative to the center element of</span>
0028 <span class="comment">%   CONN.  If specified this way, CONN must be symmetric about its center.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%   Note</span>
0031 <span class="comment">%   ----</span>
0032 <span class="comment">%   The watershed transform algorithm used by this function changed in</span>
0033 <span class="comment">%   version 5.4 (R2007a) of the Image Processing Toolbox.  The previous</span>
0034 <span class="comment">%   algorithm occasionally produced labeled watershed basins that were not</span>
0035 <span class="comment">%   contiguous.  If you need to obtain the same results as the previous</span>
0036 <span class="comment">%   algorithm, use the function WATERSHED_OLD.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%   Class Support</span>
0039 <span class="comment">%   -------------</span>
0040 <span class="comment">%   A can be a numeric or logical array of any dimension, and it must be</span>
0041 <span class="comment">%   nonsparse.  The output array L is double.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   Example (2-D)</span>
0044 <span class="comment">%   -------------</span>
0045 <span class="comment">%   1. Make a binary image containing two overlapping circular objects.</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%       center1 = -10;</span>
0048 <span class="comment">%       center2 = -center1;</span>
0049 <span class="comment">%       dist = sqrt(2*(2*center1)^2);</span>
0050 <span class="comment">%       radius = dist/2 * 1.4;</span>
0051 <span class="comment">%       lims = [floor(center1-1.2*radius) ceil(center2+1.2*radius)];</span>
0052 <span class="comment">%       [x,y] = meshgrid(lims(1):lims(2));</span>
0053 <span class="comment">%       bw1 = sqrt((x-center1).^2 + (y-center1).^2) &lt;= radius;</span>
0054 <span class="comment">%       bw2 = sqrt((x-center2).^2 + (y-center2).^2) &lt;= radius;</span>
0055 <span class="comment">%       bw = bw1 | bw2;</span>
0056 <span class="comment">%       figure, imshow(bw,'InitialMagnification','fit'), title('bw')</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%   2. Compute the distance transform of the complement of the binary</span>
0059 <span class="comment">%      image.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%       D = bwdist(~bw);</span>
0062 <span class="comment">%       figure, imshow(D,[],'InitialMagnification','fit')</span>
0063 <span class="comment">%       title('Distance transform of ~bw')</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%   3. Complement the distance transform, and force pixels that don't</span>
0066 <span class="comment">%      belong to the objects to be at -Inf.</span>
0067 <span class="comment">%</span>
0068 <span class="comment">%       D = -D;</span>
0069 <span class="comment">%       D(~bw) = -Inf;</span>
0070 <span class="comment">%</span>
0071 <span class="comment">%   4. Compute the watershed transform, and display the resulting label</span>
0072 <span class="comment">%      matrix as an RGB image.</span>
0073 <span class="comment">%</span>
0074 <span class="comment">%       L = watershed(D);</span>
0075 <span class="comment">%       rgb = label2rgb(L,'jet',[.5 .5 .5]);</span>
0076 <span class="comment">%       figure, imshow(rgb,'InitialMagnification','fit')</span>
0077 <span class="comment">%       title('Watershed transform of D')</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%   Example (3-D)</span>
0080 <span class="comment">%   -------------</span>
0081 <span class="comment">%   1. Make a 3-D binary image containing two overlapping spheres.</span>
0082 <span class="comment">%</span>
0083 <span class="comment">%       center1 = -10;</span>
0084 <span class="comment">%       center2 = -center1;</span>
0085 <span class="comment">%       dist = sqrt(3*(2*center1)^2);</span>
0086 <span class="comment">%       radius = dist/2 * 1.4;</span>
0087 <span class="comment">%       lims = [floor(center1-1.2*radius) ceil(center2+1.2*radius)];</span>
0088 <span class="comment">%       [x,y,z] = meshgrid(lims(1):lims(2));</span>
0089 <span class="comment">%       bw1 = sqrt((x-center1).^2 + (y-center1).^2 + ...</span>
0090 <span class="comment">%           (z-center1).^2) &lt;= radius;</span>
0091 <span class="comment">%       bw2 = sqrt((x-center2).^2 + (y-center2).^2 + ...</span>
0092 <span class="comment">%           (z-center2).^2) &lt;= radius;</span>
0093 <span class="comment">%       bw = bw1 | bw2;</span>
0094 <span class="comment">%       figure, isosurface(x,y,z,bw,0.5), axis equal, title('BW')</span>
0095 <span class="comment">%       xlabel x, ylabel y, zlabel z</span>
0096 <span class="comment">%       xlim(lims), ylim(lims), zlim(lims)</span>
0097 <span class="comment">%       view(3), camlight, lighting gouraud</span>
0098 <span class="comment">%</span>
0099 <span class="comment">%   2. Compute the distance transform.</span>
0100 <span class="comment">%</span>
0101 <span class="comment">%       D = bwdist(~bw);</span>
0102 <span class="comment">%       figure, isosurface(x,y,z,D,radius/2), axis equal</span>
0103 <span class="comment">%       title('Isosurface of distance transform')</span>
0104 <span class="comment">%       xlabel x, ylabel y, zlabel z</span>
0105 <span class="comment">%       xlim(lims), ylim(lims), zlim(lims)</span>
0106 <span class="comment">%       view(3), camlight, lighting gouraud</span>
0107 <span class="comment">%</span>
0108 <span class="comment">%   3. Complement the distance transform, force nonobject pixels to be</span>
0109 <span class="comment">%      -Inf, and then compute the watershed transform.</span>
0110 <span class="comment">%</span>
0111 <span class="comment">%       D = -D;</span>
0112 <span class="comment">%       D(~bw) = -Inf;</span>
0113 <span class="comment">%       L = watershed(D);</span>
0114 <span class="comment">%       figure, isosurface(x,y,z,L==2,0.5), axis equal</span>
0115 <span class="comment">%       title('Segmented object')</span>
0116 <span class="comment">%       xlabel x, ylabel y, zlabel z</span>
0117 <span class="comment">%       xlim(lims), ylim(lims), zlim(lims)</span>
0118 <span class="comment">%       view(3), camlight, lighting gouraud</span>
0119 <span class="comment">%       figure, isosurface(x,y,z,L==3,0.5), axis equal</span>
0120 <span class="comment">%       title('Segmented object')</span>
0121 <span class="comment">%       xlabel x, ylabel y, zlabel z</span>
0122 <span class="comment">%       xlim(lims), ylim(lims), zlim(lims)</span>
0123 <span class="comment">%       view(3), camlight, lighting gouraud</span>
0124 <span class="comment">%</span>
0125 <span class="comment">%   See also BWLABEL, BWLABELN, REGIONPROPS, WATERSHED_OLD.</span>
0126 
0127 <span class="comment">%   Copyright 1993-2006 The MathWorks, Inc.</span>
0128 <span class="comment">%   $Revision: 1.10.4.7 $  $Date: 2006/10/14 12:22:54 $</span>
0129 
0130 <span class="comment">% Input-output specs</span>
0131 <span class="comment">% ==================</span>
0132 <span class="comment">% A    - full, real, numeric, logical</span>
0133 <span class="comment">%        +/- Inf OK, but NaNs not allowed</span>
0134 <span class="comment">%        empty OK</span>
0135 <span class="comment">%        required</span>
0136 <span class="comment">%</span>
0137 <span class="comment">% CONN - connectivity; see connectivity spec</span>
0138 <span class="comment">%        optional; if not specified = ones(repmat(3,1,ndims(A)))</span>
0139 <span class="comment">%</span>
0140 <span class="comment">% L      full, double array, same size as A</span>
0141 
0142 [A,conn] = <a href="#_sub4" class="code" title="subfunction [A,conn] = parse_inputs(varargin)">parse_inputs</a>(varargin{:});
0143 <span class="comment">%M = local_bwlabel(imregionalmin(A,conn),conn);</span>
0144 pix=find(A==min(min(A)));
0145 B=zeros(size(A));
0146 B(pix)=1;
0147 <span class="comment">%figure; imshow(B);</span>
0148 M = <a href="#_sub1" class="code" title="subfunction L = local_bwlabel(BW, conn)">local_bwlabel</a>(B,conn);
0149 L = watershed_meyer(A,conn,M);
0150 
0151 <span class="comment">%====================================================================</span>
0152 <span class="comment">% The function bwlabel is faster than bwlabeln, but bwlabel only</span>
0153 <span class="comment">% supports 2-D inputs, and a conn specified as either 4 or 8.</span>
0154 <span class="comment">% local_bwlabel uses bwlabel when possible; otherwise it uses</span>
0155 <span class="comment">% bwlabeln.</span>
0156 <a name="_sub1" href="#_subfunctions" class="code">function L = local_bwlabel(BW, conn)</a>
0157 <span class="keyword">if</span> ndims(BW) == 2
0158     <span class="keyword">if</span> <a href="#_sub3" class="code" title="subfunction tf = is8Conn(conn)">is8Conn</a>(conn)
0159         labeler = @(BW) bwlabel(BW, 8);
0160         
0161     <span class="keyword">elseif</span> <a href="#_sub2" class="code" title="subfunction tf = is4Conn(conn)">is4Conn</a>(conn)
0162         labeler = @(BW) bwlabel(BW, 4);
0163         
0164     <span class="keyword">else</span>
0165         labeler = @(BW) bwlabeln(BW, conn);
0166     <span class="keyword">end</span>
0167 <span class="keyword">else</span>
0168     labeler = @(BW) bwlabeln(BW, conn);
0169 <span class="keyword">end</span>
0170 
0171 L = labeler(BW);
0172 <span class="comment">%--------------------------------------------------------------------</span>
0173 
0174 <span class="comment">%====================================================================</span>
0175 <span class="comment">% is4Conn</span>
0176 <span class="comment">% True if the connectivity specifier is either the value 4, or is</span>
0177 <span class="comment">% [0 1 0; 1 1 1; 0 1 0].</span>
0178 <span class="comment">%</span>
0179 <a name="_sub2" href="#_subfunctions" class="code">function tf = is4Conn(conn)</a>
0180 
0181 tf = isequal(conn, 4) || isequal(logical(conn), logical([0 1 0; 1 1 1; 0 1 0]));
0182 <span class="comment">%--------------------------------------------------------------------</span>
0183 
0184 <span class="comment">%====================================================================</span>
0185 <span class="comment">% is8Conn</span>
0186 <span class="comment">% True if the connectivity specifier is either the value 8, or is</span>
0187 <span class="comment">% ones(3,3).</span>
0188 <span class="comment">%</span>
0189 <a name="_sub3" href="#_subfunctions" class="code">function tf = is8Conn(conn)</a>
0190 
0191 tf = isequal(conn, 8) || isequal(logical(conn), true(3,3));
0192 <span class="comment">%--------------------------------------------------------------------</span>
0193 
0194 <span class="comment">%====================================================================</span>
0195 <a name="_sub4" href="#_subfunctions" class="code">function [A,conn] = parse_inputs(varargin)</a>
0196   
0197 iptchecknargin(1,2,nargin,mfilename);
0198 
0199 A = varargin{1};
0200 iptcheckinput(A,{<span class="string">'numeric'</span> <span class="string">'logical'</span>}, {<span class="string">'real'</span> <span class="string">'nonsparse'</span>}, <span class="keyword">...</span>
0201               mfilename, <span class="string">'A'</span>, 1);
0202 
0203 <span class="keyword">if</span> nargin &lt; 2
0204     conn = conndef(ndims(A), <span class="string">'maximal'</span>);
0205 <span class="keyword">else</span>
0206     conn = varargin{2};
0207     <span class="keyword">if</span> isa(conn,<span class="string">'strel'</span>)
0208         conn = getnhood(conn);
0209     <span class="keyword">end</span>
0210     iptcheckconn(conn, mfilename, <span class="string">'CONN'</span>, 2);
0211 <span class="keyword">end</span>
0212 <span class="comment">%--------------------------------------------------------------------</span></pre></div>
<hr><address>Generated on Wed 27-Oct-2010 20:01:59 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>