<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of phy_ballModel</title>
  <meta name="keywords" content="phy_ballModel">
  <meta name="description" content="ball model is a further evolution of ball that lets one relax many cells">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- # phyloCell -->
<h1>phy_ballModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>ball model is a further evolution of ball that lets one relax many cells</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [xnew ynew bre]=phy_ballModel(x,y,gradx,grady,option) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ball model is a further evolution of ball that lets one relax many cells
 in parallel</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="phy_getCellCenter.html" class="code" title="function [a b]=phy_getCellCenter(x,y)">phy_getCellCenter</a>	get the center of the cells</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="phy_segmentCellsBallon.html" class="code" title="function cellsout=phy_segmentCellsBallon(image,cellsin,option,killcells,parametres)">phy_segmentCellsBallon</a>	find cell center based on phase image using bwdist to detect cell centers and</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [xout yout] = equallySpaceVertices(x,y,nx)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [xnew ynew bre]=phy_ballModel(x,y,gradx,grady,option)</a>
0003 <span class="comment">% ball model is a further evolution of ball that lets one relax many cells</span>
0004 <span class="comment">% in parallel</span>
0005 
0006 display=0; 
0007 sca=1;
0008 
0009 <span class="keyword">if</span> nargin==5
0010     <span class="keyword">switch</span> option
0011         <span class="keyword">case</span> <span class="string">'scale'</span>
0012             sca=0.5;  
0013             
0014         <span class="keyword">case</span> <span class="string">'display'</span>
0015             display=1; 
0016         <span class="keyword">case</span> <span class="string">'daughter'</span>
0017             <span class="comment">%display=1;</span>
0018     <span class="keyword">end</span>
0019 <span class="keyword">end</span>
0020 display=1;
0021 
0022 <span class="comment">%sca=0.95;</span>
0023     
0024 <span class="keyword">for</span> i=1:size(x,2)
0025     [xtemp ytemp] = <a href="#_sub1" class="code" title="subfunction [xout yout] = equallySpaceVertices(x,y,nx)">equallySpaceVertices</a>(x(:,i),y(:,i),size(x,1));
0026     <span class="comment">%x=x(1:numel(x)-1);</span>
0027     <span class="comment">%y=y(1:numel(y)-1);</span>
0028     <span class="comment">%nv= numel(x)</span>
0029     
0030      xtemp=xtemp(1:numel(xtemp)-1)';
0031      ytemp=ytemp(1:numel(ytemp)-1)';
0032    
0033     
0034     <span class="keyword">if</span> sca~=1
0035     
0036     xtemp=sca*(xtemp-mean(xtemp))+mean(xtemp);
0037     ytemp=sca*(ytemp-mean(ytemp))+mean(ytemp);
0038     <span class="keyword">end</span>
0039     
0040     x(:,i)=xtemp;
0041     y(:,i)=ytemp;
0042 <span class="keyword">end</span>
0043 
0044     nv=size(x,1);
0045 
0046 
0047 
0048 nstep=1000; <span class="comment">% number of integration steps 3000</span>
0049 k=0.3; <span class="comment">% spring stiffness &lt; 0.5 %0.3</span>
0050 gradalpha=6; <span class="comment">% sensitivity to image gradient</span>
0051 dt=1;
0052 S= polyarea(x,y); <span class="comment">%final surface without image (pixel units)</span>
0053 
0054 Sini=S;
0055 Smin=Sini;
0056 
0057 
0058 
0059 <span class="keyword">if</span> nargin==5
0060     <span class="keyword">if</span> strcmp(option,<span class="string">'scale'</span>)
0061        Smin= Sini/(sca*sca);
0062     <span class="keyword">end</span>
0063     
0064     <span class="keyword">if</span> strcmp(option,<span class="string">'daughter'</span>)
0065        <span class="keyword">for</span> ic=1:size(x,2)
0066        Smin(ic)= 1500;
0067        <span class="keyword">end</span>
0068     <span class="keyword">end</span>
0069 <span class="keyword">end</span>
0070 
0071 <span class="comment">%Smin= Sini/(sca*sca)</span>
0072 
0073 growth_factor=70; <span class="comment">% speed at which the balloon inflates % default : 30</span>
0074 nmole=k*S*tan(pi/nv);
0075 
0076 
0077 cou=0; <span class="comment">% bending rigidity 0.1?</span>
0078 taille=size(gradx);
0079 
0080 s=polyarea(x,y);
0081 p=nmole./s;
0082 
0083 
0084 <span class="comment">%d1x=x-circshift(x,1);</span>
0085 <span class="comment">%d2x=circshift(x,-1)-x;</span>
0086     
0087 <span class="comment">%d1y=y-circshift(y,1);</span>
0088 <span class="comment">%d2y=circshift(y,-1)-y;</span>
0089  
0090 temp=zeros(1,size(x,1));
0091 
0092 gradx2=gradx+min(min(gradx));
0093 
0094 <span class="keyword">if</span> display
0095    mil= min(min(-gradx2));
0096    mal= max(max(-gradx2));
0097 figure, imshow(-gradx2,[mil+0.3*(mal-mil) mil+0.8*(mal-mil)]);
0098 <span class="comment">%x,y</span>
0099 h=line(x,y,<span class="string">'color'</span>,<span class="string">'r'</span>);
0100 pause(0.003);
0101 <span class="comment">%pause;</span>
0102 <span class="keyword">end</span>
0103   
0104 
0105   x_old=x;
0106   y_old=y;
0107   p_store=zeros(nstep,size(x,2));
0108   
0109   S_real=zeros(nstep,size(x,2));
0110   S_asked=zeros(nstep,size(x,2));
0111   
0112   s_old=s;
0113   x_store=zeros(size(x,1),size(x,2),nstep);
0114   y_store=zeros(size(x,1),size(x,2),nstep);
0115   
0116 xnew=x;
0117 ynew=y;
0118 
0119 bre=ones(1,size(x,2));
0120 pressure_count=uint16(10000*ones(1,size(x,2)));
0121 count=0;
0122 
0123 <span class="keyword">for</span> i=1:nstep
0124     <span class="comment">%i,x,y</span>
0125     d1x=x-circshift(x,1);
0126     d2x=circshift(x,-1)-x;
0127     
0128     d1y=y-circshift(y,1);
0129     d2y=circshift(y,-1)-y;
0130     
0131     <span class="comment">% cross product to determine the oritentation of pressure vector</span>
0132     press1a=zeros(size(x,1),3,size(x,2));
0133     press1a(:,1,:)=d1y;
0134     press1a(:,2,:)=-d1x;
0135   
0136     press1b=zeros(size(x,1),3,size(x,2));
0137     press1b(:,1,:)=d1x;
0138     press1b(:,2,:)=d1y;
0139     
0140     
0141     c1=sign(cross(press1a,press1b));
0142     c1=permute(c1,[1 3 2]);
0143     c1=c1(:,:,3);
0144 
0145     <span class="comment">%-----------------------------------</span>
0146     <span class="comment">% cross product to calculate angle between segment</span>
0147     press2a=zeros(size(x,1),3,size(x,2));
0148     press2a(:,1,:)=d2y;
0149     press2a(:,2,:)=-d2x;
0150   
0151     press2b=zeros(size(x,1),3,size(x,2));
0152     press2b(:,1,:)=d2x;
0153     press2b(:,2,:)=d2y;
0154     
0155     
0156     c2=sign(cross(press2a,press2b));
0157     c2=permute(c2,[1 3 2]);
0158     c2=c2(:,:,3);
0159   
0160     
0161     r1=zeros(size(x,1),3,size(x,2));
0162     r1(:,1,:)=d1x;
0163     r1(:,2,:)=d1y;
0164   
0165     r2=zeros(size(x,1),3,size(x,2));
0166     r2(:,1,:)=d2x;
0167     r2(:,2,:)=d2y;
0168     
0169     cr=sign(cross(r1,r2));
0170     cr=permute(cr,[1 3 2]);
0171     cr=cr(:,:,3);
0172     
0173 
0174     
0175     sinthetai=cr./(sqrt(d1x.*d1x+d1y.*d1y).*sqrt(d2x.*d2x+d2y.*d2y));
0176     
0177     a=sinthetai.*sinthetai;
0178     <span class="comment">%a=sqrt(1./a-1)</span>
0179     a=1./(1-a);
0180     tanthetai=sqrt(a-1);
0181     
0182     xm=(circshift(x,1)+circshift(x,-1))/2;
0183     ym=(circshift(y,1)+circshift(y,-1))/2;
0184     
0185     courbx= (xm-x); <span class="comment">%./sqrt( (xm-x).*(xm-x) + (ym-y).*(ym-y) );</span>
0186     courby= (ym-y); <span class="comment">%./sqrt( (xm-x).*(xm-x) + (ym-y).*(ym-y) );</span>
0187     
0188 
0189    
0190     warning off all;
0191     tempx=uint32(round(x));
0192     tempy=uint32(round(y));
0193     warning on all;
0194    
0195 
0196     
0197     maxe=max(tempx);
0198     badcells=find(maxe&gt;size(gradx,2));
0199     <span class="comment">%zae=size(gradx,1);</span>
0200     
0201     maye=max(tempy);
0202     badcells=[badcells find(maye&gt;size(gradx,1))];
0203     
0204     mix=min(tempx);
0205     badcells=[badcells find(mix&lt;0)];
0206     
0207     miy=min(tempy);
0208     badcells=[badcells find(miy&lt;0)];
0209     
0210     <span class="comment">% stop cells that are too big ?</span>
0211    <span class="comment">% badcells</span>
0212    <span class="comment">%%% may remove it</span>
0213     s=polyarea(x,y);
0214    <span class="comment">% tooBigCells=find(s&gt;15000);</span>
0215     tooBigCells=[];
0216     badcells=[badcells tooBigCells];
0217     <span class="comment">%badcells</span>
0218     
0219     <span class="comment">%badcells</span>
0220     bre(badcells)=0;
0221     
0222     
0223 
0224     
0225     <span class="keyword">if</span> mean(bre)==0
0226        
0227         <span class="keyword">break</span>;
0228     <span class="keyword">end</span>
0229      
0230     pix=find(tempx&lt;=0)';
0231     piy=find(tempy&lt;=0)';
0232     
0233     tox=find(tempx&gt;size(gradx,2))';
0234     pix=[pix tox];
0235     
0236     <span class="comment">%toto=find(tempx&gt;size(grady,1)),size(toto)</span>
0237     
0238     toy=find(tempy&gt;size(gradx,1))';
0239     piy=[piy toy];
0240     
0241     warning off all;
0242     index=tempy+taille(1)*(tempx-1);
0243     warning on all;
0244     
0245     
0246     <span class="comment">%index = sub2ind(taille,tempy,tempx);</span>
0247     
0248     index(pix)=1;
0249     index(piy)=1;
0250 
0251 
0252     ax=gradx(index);
0253     ay=grady(index);
0254   
0255 
0256   
0257     x_old=x;
0258     y_old=y;
0259     
0260     bre2=repmat(bre,size(x,1),1);
0261     <span class="comment">%return;</span>
0262     pressure=repmat(p,size(x,1),1);
0263     
0264 
0265     
0266     x=x+bre2.*(k*(d2x-d1x)+pressure.*(c1.*d1y+c2.*d2y) +cou*courbx.*tanthetai-ax*gradalpha)*dt;
0267     y=y+bre2.*(k*(d2y-d1y)+pressure.*(-c1.*d1x-c2.*d2x)+cou*courby.*tanthetai-ay*gradalpha)*dt;
0268     
0269      
0270     x_store(:,:,i)=x;
0271     y_store(:,:,i)=y;
0272 
0273     
0274     s_old=s;
0275     s=polyarea(x,y);
0276     
0277     
0278     S_real(i,:)=s;
0279     S_asked(i,:)=S;
0280     
0281     p=nmole./s;
0282     
0283     <span class="comment">% identify pressure drop corresponding to balloon explosion</span>
0284     
0285     <span class="keyword">for</span> j=1:size(x,2)
0286         <span class="keyword">if</span> s(j)-0.9*Smin(j)&gt;0
0287             pressure_count(j)=min(pressure_count(j),i);
0288         <span class="keyword">end</span>      
0289   <span class="comment">% bigCells=find(s-0.9*Smin&gt;0);</span>
0290  <span class="comment">%  pressure_count(bigCells)=min(pressure_count(bigCells),i);</span>
0291 <span class="comment">%   pressure_count,Smin</span>
0292    
0293    p_store(1:pressure_count(j),j)=0;
0294    
0295    pmax(j)=0.8*max(p_store(:,j));
0296     <span class="keyword">end</span>
0297    
0298    deflatingcells=find(p-pmax&lt;0);
0299    
0300    <span class="comment">%if s(deflatingcells)&gt;1500 %try</span>
0301    bre(deflatingcells)=0;
0302   <span class="comment">% else</span>
0303      <span class="comment">%fprintf('warning : cell is too small, keep inflating\n')%</span>
0304      
0305   <span class="comment">% end</span>
0306   <span class="comment">% bre</span>
0307   
0308    <span class="keyword">if</span> mean(bre)==0
0309        <span class="comment">%i</span>
0310      <span class="comment">%  'normal stop'</span>
0311         <span class="keyword">break</span>;
0312    <span class="keyword">end</span>
0313     
0314     
0315     p_store(i,:)=p;
0316 
0317    <span class="keyword">if</span> display
0318    <span class="keyword">if</span> mod(i,5)==0
0319    delete(h);
0320    h=line(x,y,<span class="string">'color'</span>,<span class="string">'r'</span>);
0321    pause(0.01);
0322  <span class="comment">% Sini,S,s</span>
0323 <span class="comment">% nmole</span>
0324    <span class="comment">%pause;</span>
0325 
0326    <span class="keyword">end</span>
0327    <span class="keyword">end</span>
0328    
0329    S=Sini+growth_factor*double(i/nstep)*Sini.*bre;
0330    nmole=k*S*tan(pi/nv);
0331   
0332    <span class="comment">%close(figure);</span>
0333 
0334 <span class="keyword">end</span>
0335 
0336 
0337 <span class="comment">%size(p_store)</span>
0338 <span class="comment">%p_store=p_store(200:nstep,:);</span>
0339 
0340 [ma ix]=max(p_store);
0341 
0342 <span class="keyword">if</span> display
0343     
0344 close(gcf);
0345 <span class="keyword">end</span>
0346 
0347 <span class="comment">%if ix&gt;10</span>
0348 <span class="comment">%    ix=ix-10;</span>
0349 <span class="comment">%end</span>
0350 
0351 <span class="comment">%figure;</span>
0352 
0353 <span class="keyword">for</span> i=1:numel(p)
0354     <span class="keyword">if</span> ix(i)&gt;10
0355         ix(i)=ix(i)-10;
0356     <span class="keyword">end</span>
0357     
0358    <span class="comment">%if S_real(ix(i))&lt;2000;</span>
0359 xnew(:,i)=x_store(:,i,ix(i));
0360 ynew(:,i)=y_store(:,i,ix(i));
0361 <span class="keyword">end</span>
0362 
0363 
0364 bre(tooBigCells)=1;
0365 
0366 <span class="comment">%if nargin==5</span>
0367 <span class="comment">% if strcmp(option,'daughter')</span>
0368 <span class="comment">%      finalsurf=polyarea(xnew(:,1),ynew(:,1))</span>
0369 <span class="comment">% end</span>
0370 <span class="comment">%end</span>
0371 
0372 <span class="comment">%figure, plot(p_store);</span>
0373 
0374 <span class="comment">%figure, plot(S_real);</span>
0375 
0376 
0377 <span class="comment">%figure, plot(S_asked,S_real);</span>
0378 
0379 <span class="comment">%figure, plot(inflate_timing,test_ratio);</span>
0380 
0381  
0382  <span class="keyword">function</span> [xout yout] = <a href="#_sub1" class="code" title="subfunction [xout yout] = equallySpaceVertices(x,y,nx)">equallySpaceVertices</a>(x,y,nx)
0383 
0384 <span class="comment">% spaces vertices according to an even angular distribution</span>
0385 
0386 [a b]=<a href="phy_getCellCenter.html" class="code" title="function [a b]=phy_getCellCenter(x,y)">phy_getCellCenter</a>(x,y);
0387 
0388 
0389 distmax=2 * sqrt(max(x-a)*max(x-a)+max(y-b)*max(y-b));
0390 m=round(distmax)+10;
0391 n=round(distmax)+10;
0392 
0393 tx=x-a+m/2;
0394 ty=y-b+n/2;
0395 
0396 BW = poly2mask(tx,ty,m,n);
0397 <span class="comment">%figure, imshow(BW,[])</span>
0398 theta= 2*pi/nx;
0399 
0400 <span class="keyword">for</span> (i=1:nx+1)
0401 vec = [ cos((i-1)*theta) sin((i-1)*theta) ];
0402 <span class="keyword">for</span> (j=1:m/2)
0403    pix(1)=round(m/2+j*vec(1));
0404    pix(2)=round(n/2+j*vec(2));
0405    <span class="keyword">if</span> ( BW(pix(2),pix(1))==0)
0406        ind=j;
0407        <span class="keyword">break</span>;
0408    <span class="keyword">end</span>
0409 <span class="keyword">end</span>
0410 <span class="comment">%contour=improfile(BW,[m/2 m/2*(1+2*vec(1))],[n/2 n/2*(1+2*vec(2))],'bicubic');</span>
0411 <span class="comment">%[mine ind]=min(contour);</span>
0412 xout(i)=m/2+vec(1)*ind;
0413 yout(i)=n/2+vec(2)*ind;
0414 <span class="keyword">end</span>
0415 
0416 <span class="comment">%figure,imshow(BW); hold on; line(xout,yout,'Color','r','Marker','x');</span>
0417 
0418 
0419 xout=xout+a-m/2;
0420 yout=yout+b-n/2;
0421  
0422 xout=smooth(xout);
0423 yout=smooth(yout);
0424 
0425</pre></div>
<hr><address>Generated on Wed 27-Oct-2010 20:01:59 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>